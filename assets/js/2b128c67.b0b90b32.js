"use strict";(self.webpackChunkkuby_docs=self.webpackChunkkuby_docs||[]).push([[785],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return m}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(t),m=i,g=c["".concat(s,".").concat(m)]||c[m]||d[m]||r;return t?a.createElement(g,o(o({ref:n},p),{},{components:t})):a.createElement(g,o({ref:n},p))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=c;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var u=2;u<r;u++)o[u]=t[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},9841:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return d}});var a=t(7462),i=t(3366),r=(t(7294),t(3905)),o=["components"],l={id:"creating-plugins",title:"Creating Your Own Plugins",sidebar_label:"Creating Your Own Plugins",slug:"/creating-plugins"},s=void 0,u={unversionedId:"creating-plugins",id:"creating-plugins",title:"Creating Your Own Plugins",description:"Kuby features a plugin system that makes it easy to add your own functionality. In fact, much of Kuby's own feature set is implemented as a series of plugins.",source:"@site/docs/creating_plugins.md",sourceDirName:".",slug:"/creating-plugins",permalink:"/docs/creating-plugins",editUrl:"https://github.com/getkuby/kuby-core/edit/master/docs/docs/creating_plugins.md",tags:[],version:"current",frontMatter:{id:"creating-plugins",title:"Creating Your Own Plugins",sidebar_label:"Creating Your Own Plugins",slug:"/creating-plugins"},sidebar:"sidebar",previous:{title:"Customizing Deployments",permalink:"/docs/customizing-deployments"},next:{title:"Environment Variables",permalink:"/docs/environment-variables"}},p={},d=[{value:"Anatomy of a Plugin",id:"anatomy-of-a-plugin",level:2},{value:"Registering Your Plugin",id:"registering-your-plugin",level:2},{value:"Plugin Lifecycle Methods",id:"plugin-lifecycle-methods",level:2},{value:"Creating Additional Kubernetes Resources",id:"creating-additional-kubernetes-resources",level:2},{value:"Custom Resource Definitions (CRDs)",id:"custom-resource-definitions-crds",level:2},{value:"Specifying Additional Docker Images",id:"specifying-additional-docker-images",level:2},{value:"Creating a Dockerfile",id:"creating-a-dockerfile",level:3},{value:"Creating an Image",id:"creating-an-image",level:3},{value:"Exposing the Image",id:"exposing-the-image",level:3}],c={toc:d};function m(e){var n=e.components,t=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Kuby features a plugin system that makes it easy to add your own functionality. In fact, much of Kuby's own feature set is implemented as a series of plugins."),(0,r.kt)("h2",{id:"anatomy-of-a-plugin"},"Anatomy of a Plugin"),(0,r.kt)("p",null,"Plugins are just Ruby classes that inherit from ",(0,r.kt)("inlineCode",{parentName:"p"},"Kuby::Plugin"),". The plugin interface, i.e. the methods plugins are expected to respond to, are summarized below."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"configure(&block)"),": Called when the plugin is added to a Kuby environment. In other words:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"Kuby.define('my-app') do\n  environment(:production) do\n    add_plugin(:my_plugin) do\n      # at this point, the plugin's `configure' method is called\n      # and handed this block\n    end\n  end\nend\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"setup()"),": Called during setup, i.e. whenever the ",(0,r.kt)("inlineCode",{parentName:"p"},"kuby setup")," command is executed. Since ",(0,r.kt)("inlineCode",{parentName:"p"},"kuby setup")," can be executed multiple times during the lifetime of an application (eg. when new plugins are added, etc), ",(0,r.kt)("inlineCode",{parentName:"p"},"#setup")," routines should be idempotent.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"remove()"),": Should do the opposite of whatever ",(0,r.kt)("inlineCode",{parentName:"p"},"setup()")," does. A plugin's ",(0,r.kt)("inlineCode",{parentName:"p"},"#remove")," routine is only invoked when the special ",(0,r.kt)("inlineCode",{parentName:"p"},"kuby plugin remove [plugin name]")," command is executed.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"resources()"),": Returns an array of ",(0,r.kt)("inlineCode",{parentName:"p"},"KubeDSL::DSLObject")," objects. See below for additional information regarding creating Kubernetes resource objects.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"docker_images()"),": Returns an array of ",(0,r.kt)("inlineCode",{parentName:"p"},"Kuby::Docker::Image")," objects. These images will be built on ",(0,r.kt)("inlineCode",{parentName:"p"},"kuby build")," and pushed on ",(0,r.kt)("inlineCode",{parentName:"p"},"kuby push"),". See below for additional information regarding creating Docker images.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"after_initialize()"),": Called by the base ",(0,r.kt)("inlineCode",{parentName:"p"},"Kuby::Plugin#initialize")," method. Designed to avoid forcing the plugin author call ",(0,r.kt)("inlineCode",{parentName:"p"},"super")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"#initialize"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"self.task_dirs()"),": Returns an array of paths containing .rake files. Through this mechanism plugins can define Rake tasks that can be executed using the ",(0,r.kt)("inlineCode",{parentName:"p"},"kuby")," command."))),(0,r.kt)("h2",{id:"registering-your-plugin"},"Registering Your Plugin"),(0,r.kt)("p",null,"Plugins must be registered with Kuby's plugin system before they can be used. Register your plugin like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"Kuby.register_plugin(:my_plugin, MyPlugin)\n")),(0,r.kt)("h2",{id:"plugin-lifecycle-methods"},"Plugin Lifecycle Methods"),(0,r.kt)("p",null,"In addition to the methods described above, plugins should also respond to a series of lifecycle methods summarized below."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"after_configuration()"),": Called after all plugins have been configured."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"before_setup()"),": Called before any plugins have been setup."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"after_setup()"),": Called after all plugins have been setup."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"before_deploy(manifest)"),": Called before deploying any resources. The ",(0,r.kt)("inlineCode",{parentName:"li"},"manifest")," argument is an instance of ",(0,r.kt)("inlineCode",{parentName:"li"},"Kuby::Kubernetes::Manifest")," and contains a list of all the Kubernetes resources Kuby intends to deploy."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"after_deploy(manifest)"),": Called after deploying all resources. The ",(0,r.kt)("inlineCode",{parentName:"li"},"manifest")," argument is an instance of ",(0,r.kt)("inlineCode",{parentName:"li"},"Kuby::Kubernetes::Manifest")," and contains a list of all the Kubernetes resources Kuby has just deployed.")),(0,r.kt)("h2",{id:"creating-additional-kubernetes-resources"},"Creating Additional Kubernetes Resources"),(0,r.kt)("p",null,"Kuby uses ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/getkuby/kube-dsl"},"KubeDSL")," to define Kubernetes resources in Ruby code. KubeDSL is a complete representation of the Kubernetes schema, so it's possible to create any kind of Kubernetes resource. For example, here's how to create a Kubernetes \"config map\". Config maps can be used to store bits of config data (or even the contents of entire files) that can be subsequently attached to pods and made available to your application:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"KubeDSL.config_map do\n  metadata do\n    # The name of this config map. Must be unique within the\n    # given namespace.\n    name 'my-config-map'\n\n    # This is how to get the name of the namespace your app runs in.\n    namespace Kuby.environment.kubernetes.namespace.metadata.name\n  end\n\n  data do\n    add 'VAR_NAME', 'VAR_VALUE'\n    # etc, etc\n  end\nend\n")),(0,r.kt)("p",null,"This config map object will be deployed if it is returned it from the ",(0,r.kt)("inlineCode",{parentName:"p"},"#resources")," method in your plugin:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"class MyPlugin < Kuby::Plugin\n  def resources\n    [config_map]\n  end\n\n  private\n\n  def config_map\n    @config_map ||= KubeDSL.config_map do\n      # (see above)\n    end\n  end\nend\n")),(0,r.kt)("h2",{id:"custom-resource-definitions-crds"},"Custom Resource Definitions (CRDs)"),(0,r.kt)("p",null,"A number of the plugins in the Kuby ecosystem contain DSL objects built from Custom Resource Definitions, or CRDs. CRDs are Kubernetes API extensions. They augment the set of objects in the Kubernetes API with custom ones defined by 3rd-party developers. For example, the CockroachDB Kubernetes operator defines a ",(0,r.kt)("inlineCode",{parentName:"p"},"CrdbCluster")," object. The operator listens for objects of type ",(0,r.kt)("inlineCode",{parentName:"p"},"CrdbCluster")," and acts accordingly, creating the necessary resources in the cluster to satisfy the object's properties."),(0,r.kt)("p",null,"See the Rakefiles in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/getkuby/kuby-crdb"},"kuby-crdb")," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/getkuby/kuby-cert-manager"},"kuby-cert-manager")," for examples of Kuby plugins that make use of DSL objects generated from CRDs."),(0,r.kt)("h2",{id:"specifying-additional-docker-images"},"Specifying Additional Docker Images"),(0,r.kt)("p",null,"As mentioned above, plugins can define additional Docker images that will be built and pushed on ",(0,r.kt)("inlineCode",{parentName:"p"},"kuby build")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"kuby push"),", as well as listed in the output of ",(0,r.kt)("inlineCode",{parentName:"p"},"kuby dockerfiles"),", etc."),(0,r.kt)("p",null,"In Kuby, Docker images are defined via classes that inherit from a subclass of ",(0,r.kt)("inlineCode",{parentName:"p"},"Kuby::Docker::Image"),", most often ",(0,r.kt)("inlineCode",{parentName:"p"},"Kuby::Docker::TimestampedImage"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"TimestampedImage")," class versions images by using timestamped Docker tags. These tags can be programmatically ordered so as to know which image is the most recent, second most recent, etc."),(0,r.kt)("h3",{id:"creating-a-dockerfile"},"Creating a Dockerfile"),(0,r.kt)("p",null,"Before creating an ",(0,r.kt)("inlineCode",{parentName:"p"},"Image")," subclass, you'll need to create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Kuby::Docker::Dockerfile")," instance. For a complete list of the supported directives, see the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/getkuby/kuby-core/blob/c4f5b1fd1d7cc6ff4532f7904b2462ce3e06d110/lib/kuby/docker/dockerfile.rb#L117"},"source code")," in kuby-core."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"df = Kuby::Docker::Dockerfile.new\ndf.from('ruby:3.1.0')\ndf.cmd('ruby -e \"puts \\'Hello, world!\\'\"')\n")),(0,r.kt)("h3",{id:"creating-an-image"},"Creating an Image"),(0,r.kt)("p",null,"Next, create an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"TimestampedImage"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"image = Kuby::Docker::TimestampedImage.new(\n  # the dockerfile instance\n  df,\n\n  # the registry URL for this image\n  'docker.pkg.github.com/<username>/<repo>/<image-name>',\n\n  # the Docker registry index URL, only needed if the Docker index\n  # and pull/push APIs are served using different URLs\n  nil,\n\n  # the tag to use\n  'latest',\n\n  # an array of alias tags to tag the image with\n  ['foobar']\n)\n")),(0,r.kt)("h3",{id:"exposing-the-image"},"Exposing the Image"),(0,r.kt)("p",null,"Finally, return the image from your plugin:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"class MyPlugin < Kuby::Plugin\n  def docker_images\n    [image]\n  end\n\n  private\n\n  def image\n    @image ||= Kuby::Docker::TimestampedImage.new(...) # the code from above\n  end\nend\n")),(0,r.kt)("p",null,"Running ",(0,r.kt)("inlineCode",{parentName:"p"},"bundle exec kuby -e production build")," should now build your custom image as well as the usual ones."))}m.isMDXComponent=!0}}]);