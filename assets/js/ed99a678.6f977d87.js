"use strict";(self.webpackChunkkuby_docs=self.webpackChunkkuby_docs||[]).push([[404],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),c=p(n),m=i,k=c["".concat(s,".").concat(m)]||c[m]||u[m]||l;return n?a.createElement(k,o(o({ref:t},d),{},{components:n})):a.createElement(k,o({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,o=new Array(l);o[0]=c;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var p=2;p<l;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},3605:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return r},metadata:function(){return p},toc:function(){return u}});var a=n(7462),i=n(3366),l=(n(7294),n(3905)),o=["components"],r={id:"customizing-docker-build",title:"Customizing the Docker Build",sidebar_label:"Customizing the Docker Build",slug:"/customizing-docker-build"},s=void 0,p={unversionedId:"customizing-docker-build",id:"customizing-docker-build",title:"Customizing the Docker Build",description:"We've already seen the standard way to configure Kuby's Docker component (i.e. the docker do ... end section), but there's a lot more you can do.",source:"@site/docs/customizing_docker_build.md",sourceDirName:".",slug:"/customizing-docker-build",permalink:"/docs/customizing-docker-build",editUrl:"https://github.com/getkuby/kuby-core/edit/master/docs/docs/customizing_docker_build.md",tags:[],version:"current",frontMatter:{id:"customizing-docker-build",title:"Customizing the Docker Build",sidebar_label:"Customizing the Docker Build",slug:"/customizing-docker-build"},sidebar:"sidebar",previous:{title:"Developing with Kuby",permalink:"/docs/development"},next:{title:"Understanding Kubernetes",permalink:"/docs/understanding-kubernetes"}},d={},u=[{value:"Installing Additional Packages",id:"installing-additional-packages",level:2},{value:"Build Phases",id:"build-phases",level:2},{value:"Setup Phase",id:"setup-phase",level:3},{value:"Package Phase",id:"package-phase",level:3},{value:"Bundler Phase",id:"bundler-phase",level:3},{value:"Yarn Phase",id:"yarn-phase",level:3},{value:"Copy Phase",id:"copy-phase",level:3},{value:"App Phase",id:"app-phase",level:3},{value:"Assets Phase",id:"assets-phase",level:3},{value:"Webserver Phase",id:"webserver-phase",level:3},{value:"Creating A Custom Build Phase",id:"creating-a-custom-build-phase",level:2},{value:"Removing Build Phases",id:"removing-build-phases",level:2},{value:"Build Options",id:"build-options",level:2},{value:"Building Specific Images",id:"building-specific-images",level:3},{value:"Arbitrary <code>docker build</code> Options",id:"arbitrary-docker-build-options",level:3}],c={toc:u};function m(e){var t=e.components,n=(0,i.Z)(e,o);return(0,l.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"We've already seen the standard way to configure Kuby's Docker component (i.e. the ",(0,l.kt)("inlineCode",{parentName:"p"},"docker do ... end")," section), but there's a lot more you can do."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"app_root String"),": Set your application's root directory. This is useful if the app lives in a separate folder, eg. is a demo app for a gem, etc.")),(0,l.kt)("p",null,"All the other Docker build options are described in the sections below."),(0,l.kt)("h2",{id:"installing-additional-packages"},"Installing Additional Packages"),(0,l.kt)("p",null,"Kuby officially supports the Debian and Alpine distros of Linux for Docker images."),(0,l.kt)("p",null,"Let's install imagemagick as an example. First, we'll need to register the imagemagick package with Kuby. It just so happens both the Debian and Alpine Linux distros use the same name for their imagemagick package, meaning we can define using just its name."),(0,l.kt)("p",null,"Next, we tell Kuby to install imagemagick in the ",(0,l.kt)("inlineCode",{parentName:"p"},"docker")," section of our Kuby config:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"Kuby.register_package('imagemagick')\n\nKuby.define('my-app') do\n  environment(:production) do\n    docker do\n      package_phase.add('imagemagick')\n    end\n  end\nend\n")),(0,l.kt)("p",null,"If the package we want to install has a different name under each of the Linux distros, register it using a hash instead. Let's say we want to install the ",(0,l.kt)("inlineCode",{parentName:"p"},"dig")," command-line utility. In Debian, we'd need to install the ",(0,l.kt)("inlineCode",{parentName:"p"},"dnsutils")," package, but in Alpine we'd need ",(0,l.kt)("inlineCode",{parentName:"p"},"bind-tools"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"Kuby.register_package('dig', debian: 'dnsutils', alpine: 'bind-tools')\n\nKuby.define('my-app') do\n  environment(:production) do\n    docker do\n      package_phase.add('dig')\n    end\n  end\nend\n")),(0,l.kt)("p",null,"Finally, some packages are more complicated to install. In such cases, define a Ruby class that responds to ",(0,l.kt)("inlineCode",{parentName:"p"},"install_on_debian")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"install_on_alpine"),", and register it with Kuby."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"class WatchmanPackage < Kuby::Docker::Packages::Package\n  def install_on_debian(dockerfile)\n    dockerfile.run(<<~END)\n      git clone --no-checkout https://github.com/facebook/watchman.git \\\n        && cd watchman \\\n        && git checkout v4.7.0 \\\n        && ./autogen.sh \\\n        && ./configure \\\n        && make && make install\n    END\n  end\n\n  def install_on_alpine(dockerfile)\n    # alpine-specific statements\n  end\nend\n\nKuby.register_package('watchman', WatchmanPackage)\n\nKuby.define('my-app') do\n  environment(:production) do\n    docker do\n      package_phase.add('watchman')\n    end\n  end\nend\n")),(0,l.kt)("h2",{id:"build-phases"},"Build Phases"),(0,l.kt)("p",null,"Kuby builds Docker images in 8 build phases. The options available in the various phases are documented below."),(0,l.kt)("h3",{id:"setup-phase"},"Setup Phase"),(0,l.kt)("p",null,"The setup phase defines the Docker base image (eg. ruby:2.6.3, ruby:2.6.3-alpine, etc), sets the working directory, and defines the ",(0,l.kt)("inlineCode",{parentName:"p"},"KUBY_ENV")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"RAILS_ENV")," environment variables."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"setup_phase.base_image = String"),": Sets the Docker base image on top of which your application's image will be built. Defaults to the official Ruby image for the version of Ruby currently running the ",(0,l.kt)("inlineCode",{parentName:"li"},"kuby")," command."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"setup_phase.working_dir = String"),": Sets the working directory for the Docker image's filesystem. Application code will be copied into this directory and commands like ",(0,l.kt)("inlineCode",{parentName:"li"},"bundle install")," executed within it. Defaults to /usr/src/app."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"setup_phase.rails_env = String"),": Sets ",(0,l.kt)("inlineCode",{parentName:"li"},"RAILS_ENV"),". Defaults to the current Kuby env, which is either the value passed to the Kuby CLI tool via the ",(0,l.kt)("inlineCode",{parentName:"li"},"-e")," flag (eg. ",(0,l.kt)("inlineCode",{parentName:"li"},"kuby -e production ..."),"), or the value of the ",(0,l.kt)("inlineCode",{parentName:"li"},"KUBY_ENV")," environment variable.")),(0,l.kt)("h3",{id:"package-phase"},"Package Phase"),(0,l.kt)("p",null,"The package phase installs packages via the operating system's package manager, eg. ",(0,l.kt)("inlineCode",{parentName:"p"},"apt-get"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"apk"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"yum"),", etc. Popular packages include things like database drivers (eg. postgresql-client, sqlite3-dev), and image processing libraries (eg. imagemagick, graphicsmagick)."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"package_phase.add(package_name: Symbol)"),": Adds a package by its name. Packages must be registered ahead of time (see above)."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"package_phase.remove(package_name: Symbol)"),": Removes a package by its name.")),(0,l.kt)("h3",{id:"bundler-phase"},"Bundler Phase"),(0,l.kt)("p",null,"The Bundler phase installs all the Ruby dependencies listed in your app's Gemfile via Bundler."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"bundler_phase.version = String"),": Sets the version of Bundler to use. Defaults to the current version of Bundler being used to run the ",(0,l.kt)("inlineCode",{parentName:"li"},"kuby")," command."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"bundler_phase.gemfile = String"),": Sets the path to the Gemfile."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"bundler_phase.without = Array[String]"),": Sets the array of Bundler groups to be ignored during installation."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"bundler_phase.executable = String"),": Sets the path to the Bundler executable. Defaults to ",(0,l.kt)("inlineCode",{parentName:"li"},"bundle"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"bundler_phase.gemfiles(gemfiles: Array[String])"),": Specifies additional Gemfiles to be copied into the Docker image before installation. Useful if your main Gemfile references other Gemfiles, eg. via the ",(0,l.kt)("a",{parentName:"li",href:"https://medium.com/alliants-blog/modular-composable-gemfiles-5545c83b5319"},(0,l.kt)("inlineCode",{parentName:"a"},"eval_gemfile")," method"),".")),(0,l.kt)("h3",{id:"yarn-phase"},"Yarn Phase"),(0,l.kt)("p",null,"The Yarn phase installs all the JavaScript dependencies listed in your app's package.json via Yarn."),(0,l.kt)("h3",{id:"copy-phase"},"Copy Phase"),(0,l.kt)("p",null,"The copy phase copies your app's source code into the Docker image."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"copy_phase << String"),": Adds an additional path to copy into the image. Defaults to the current directory (eg: ./)")),(0,l.kt)("h3",{id:"app-phase"},"App Phase"),(0,l.kt)("p",null,"The app phase allows setting environment variables. These variables will be available to any commands run afterwards in the ",(0,l.kt)("inlineCode",{parentName:"p"},"docker build")," process, but will also be accessible to your application via Ruby's ",(0,l.kt)("inlineCode",{parentName:"p"},"ENV")," hash."),(0,l.kt)("h3",{id:"assets-phase"},"Assets Phase"),(0,l.kt)("p",null,"The assets phase compiles static assets managed by both the asset pipeline and Webpacker."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"app_phase.env(key: String, value: String)"),": Adds an environment variable.")),(0,l.kt)("h3",{id:"webserver-phase"},"Webserver Phase"),(0,l.kt)("p",null,"The webserver phase instructs the Docker image to use a webserver to run your app. Currently only the Rails default, ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/puma/puma"},"Puma"),", is supported (including puma in your Gemfile is all you need to do - no other configuration is necessary)."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"webserver_phase.port = Integer"),": Sets the port the webserver should listen on."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"webserver_phase.webserver = Symbol"),": Sets the webserver to use. Must be ",(0,l.kt)("inlineCode",{parentName:"li"},":puma"),". Additional webservers may be supported in the future if there is demand. The only reason to set this field manually is if Kuby can't detect Puma in your Gemfile for some reason.")),(0,l.kt)("h2",{id:"creating-a-custom-build-phase"},"Creating A Custom Build Phase"),(0,l.kt)("p",null,"Phases are just Ruby classes that respond to the ",(0,l.kt)("inlineCode",{parentName:"p"},"apply_to(dockerfile)")," method. It's possible to define your own custom phases and insert them into the build process. To do so, create a Ruby class and define the appropriate method. Then, insert your new phase. For example, let's define a phase that writes a file into the image that contains the current git commit ID (it can be handy to know which version of your code your image contains). We assume the current git commit is passed as a Docker build argument, since it won't be available to Docker otherwise (in other words, the .git folder won't and shouldn't be copied into the image)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"class GitCommitPhase\n  def apply_to(dockerfile)\n    dockerfile.run('echo $GIT_COMMIT > GIT_COMMIT')\n  end\nend\n\nKuby.define('my-app') do\n  environment(:production) do\n    docker do\n      insert :git_commit_phase, GitCommitPhase.new, after: :copy_phase\n    end\n  end\nend\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Kuby::Docker::Dockerfile")," objects respond to the following methods, which are mapped 1:1 to ",(0,l.kt)("a",{parentName:"p",href:"https://docs.docker.com/engine/reference/builder/#format"},"Dockerfile instructions"),":"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"from(image_url, as: nil)")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"workdir(path)")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"env(key, value)")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"arg(arg)")," (",(0,l.kt)("inlineCode",{parentName:"li"},"arg")," is a string of the form ",(0,l.kt)("inlineCode",{parentName:"li"},"\"KEY='value'\""),")"),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"run(command)")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"copy(source, dest, from: nil)")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"expose(port)")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"cmd(command)"))),(0,l.kt)("p",null,"Custom build phases can also be inserted inline, without the need to define a class:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"Kuby.define('my-app') do\n  environment(:production) do\n    docker do\n      insert :git_commit_phase, after: :copy_phase do |dockerfile|\n        dockerfile.run('echo $GIT_COMMIT > GIT_COMMIT')\n      end\n    end\n  end\nend\n")),(0,l.kt)("h2",{id:"removing-build-phases"},"Removing Build Phases"),(0,l.kt)("p",null,"Build phases can be removed entirely. For example, if your app is API-only and doesn't have any static assets, then you may want to remove the asset compilation phase entirely:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"Kuby.define('my-app') do\n  environment(:production) do\n    docker do\n      delete :assets_phase\n    end\n  end\nend\n")),(0,l.kt)("h2",{id:"build-options"},"Build Options"),(0,l.kt)("p",null,"It is possible to pass additional build args to ",(0,l.kt)("inlineCode",{parentName:"p"},"kuby build")," via the ",(0,l.kt)("inlineCode",{parentName:"p"},"-a")," (",(0,l.kt)("inlineCode",{parentName:"p"},"--arg"),") flag. For example, here's how to pass a build arg containing the current Git commit SHA:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"bundle exec kuby build -a SOURCE_COMMIT=$(git rev-parse HEAD)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"NOTE:")," The example above assumes the ",(0,l.kt)("inlineCode",{parentName:"p"},"SOURCE_COMMIT")," build arg has been added via a custom build phase. To be able to access the value of the arg from the Rails app, it must also be exposed as an environment variable. To accomplish both goals, try something like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ruby"},"insert :git_commit_arg, after: :setup_phase do |dockerfile|\n  dockerfile.arg('SOURCE_COMMIT')\n  dockerfile.env('SOURCE_COMMIT', '$SOURCE_COMMIT')\nend\n")),(0,l.kt)("h3",{id:"building-specific-images"},"Building Specific Images"),(0,l.kt)("p",null,"By default, ",(0,l.kt)("inlineCode",{parentName:"p"},"kuby build")," builds all the registered Docker images. Sometimes it's useful to build a specific one instead. To do so, pass the ",(0,l.kt)("inlineCode",{parentName:"p"},"--only")," option:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"bundle exec kuby build --only app  # only build the app image\n")),(0,l.kt)("p",null,"The value for the ",(0,l.kt)("inlineCode",{parentName:"p"},"--only")," option is an image identifier. A list of all registered images and their identifiers can be obtained via the ",(0,l.kt)("inlineCode",{parentName:"p"},"kuby images")," command."),(0,l.kt)("p",null,"A similar option is available for the ",(0,l.kt)("inlineCode",{parentName:"p"},"push")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"dockerfiles")," commands, e.g., ",(0,l.kt)("inlineCode",{parentName:"p"},"kuby push --only app"),"."),(0,l.kt)("h3",{id:"arbitrary-docker-build-options"},"Arbitrary ",(0,l.kt)("inlineCode",{parentName:"h3"},"docker build")," Options"),(0,l.kt)("p",null,"It is also possible to pass arbitrary options to the ",(0,l.kt)("inlineCode",{parentName:"p"},"docker build")," command:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"bundle exec kuby build -- [options]\n")),(0,l.kt)("p",null,"For example, to specify a ",(0,l.kt)("a",{parentName:"p",href:"https://docs.docker.com/engine/reference/commandline/build/#custom-build-outputs"},"custom build target"),", try this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"bundle exec kuby build -- --output type=tar,dest=out.tar\n")),(0,l.kt)("p",null,"The options given after the ",(0,l.kt)("inlineCode",{parentName:"p"},"--")," will be appended verbatim to the ",(0,l.kt)("inlineCode",{parentName:"p"},"docker build")," command."))}m.isMDXComponent=!0}}]);