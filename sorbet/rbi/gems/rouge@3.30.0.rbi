# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rouge` gem.
# Please instead update this file by running `bin/tapioca gem rouge`.


# The containing module for Rouge
#
# source://rouge//lib/rouge.rb#8
module Rouge
  class << self
    # Highlight some text with a given lexer and formatter.
    #
    # @example
    #   Rouge.highlight('@foo = 1', 'ruby', 'html')
    #   Rouge.highlight('var foo = 1;', 'js', 'terminal256')
    #
    #   # streaming - chunks become available as they are lexed
    #   Rouge.highlight(large_string, 'ruby', 'html') do |chunk|
    #   $stdout.print chunk
    #   end
    #
    # source://rouge//lib/rouge.rb#29
    def highlight(text, lexer, formatter, &b); end

    # Load a file relative to the `lib/rouge` path.
    #
    # @api private
    #
    # source://rouge//lib/rouge.rb#42
    def load_file(path); end

    # Load the lexers in the `lib/rouge/lexers` directory.
    #
    # @api private
    #
    # source://rouge//lib/rouge.rb#49
    def load_lexers; end

    # source://rouge//lib/rouge.rb#14
    def reload!; end

    # source://rouge//lib/rouge/version.rb#5
    def version; end
  end
end

# source://rouge//lib/rouge/theme.rb#163
class Rouge::CSSTheme < ::Rouge::Theme
  # @return [CSSTheme] a new instance of CSSTheme
  #
  # source://rouge//lib/rouge/theme.rb#164
  def initialize(opts = T.unsafe(nil)); end

  # @yield ["#{@scope} table td { padding: 5px; }"]
  #
  # source://rouge//lib/rouge/theme.rb#168
  def render(&b); end

  # source://rouge//lib/rouge/theme.rb#180
  def render_base(selector, &b); end

  # source://rouge//lib/rouge/theme.rb#184
  def style_for(tok); end

  private

  # source://rouge//lib/rouge/theme.rb#189
  def css_selector(token); end

  # yield all of the tokens that should be styled the same
  # as the given token.  Essentially this recursively all of
  # the subtokens, except those which are more specifically
  # styled.
  #
  # @yield [tok]
  #
  # source://rouge//lib/rouge/theme.rb#207
  def inflate_token(tok, &b); end

  # source://rouge//lib/rouge/theme.rb#197
  def single_css_selector(token); end
end

# A Formatter takes a token stream and formats it for human viewing.
#
# source://rouge//lib/rouge/formatter.rb#6
class Rouge::Formatter
  # @return [Formatter] a new instance of Formatter
  #
  # source://rouge//lib/rouge/formatter.rb#49
  def initialize(opts = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rouge//lib/rouge/formatter.rb#53
  def escape?(tok); end

  # source://rouge//lib/rouge/formatter.rb#57
  def filter_escapes(tokens); end

  # Format a token stream.
  #
  # source://rouge//lib/rouge/formatter.rb#68
  def format(tokens, &b); end

  # @deprecated Use {#format} instead.
  #
  # source://rouge//lib/rouge/formatter.rb#80
  def render(tokens); end

  # yield strings that, when concatenated, form the formatted output
  #
  # @abstract
  #
  # source://rouge//lib/rouge/formatter.rb#87
  def stream(tokens, &b); end

  protected

  # @yield [out]
  #
  # source://rouge//lib/rouge/formatter.rb#92
  def token_lines(tokens, &b); end

  class << self
    # source://rouge//lib/rouge/formatter.rb#39
    def disable_escape!; end

    # source://rouge//lib/rouge/formatter.rb#35
    def enable_escape!; end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/formatter.rb#31
    def escape_enabled?; end

    # Find a formatter class given a unique tag.
    #
    # source://rouge//lib/rouge/formatter.rb#20
    def find(tag); end

    # Format a token stream.  Delegates to {#format}.
    #
    # source://rouge//lib/rouge/formatter.rb#45
    def format(tokens, *args, **kwargs, &b); end

    # Specify or get the unique tag for this formatter.  This is used
    # for specifying a formatter in `rougify`.
    #
    # source://rouge//lib/rouge/formatter.rb#12
    def tag(tag = T.unsafe(nil)); end

    # source://rouge//lib/rouge/formatter.rb#24
    def with_escape; end
  end
end

# @private
#
# source://rouge//lib/rouge/formatter.rb#8
Rouge::Formatter::REGISTRY = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/formatters/html.rb#5
module Rouge::Formatters; end

# Transforms a token stream into HTML output.
#
# source://rouge//lib/rouge/formatters/html.rb#7
class Rouge::Formatters::HTML < ::Rouge::Formatter
  # source://rouge//lib/rouge/formatters/html.rb#21
  def safe_span(tok, safe_val); end

  # source://rouge//lib/rouge/formatters/html.rb#15
  def span(tok, val); end

  # @yield the html output.
  #
  # source://rouge//lib/rouge/formatters/html.rb#11
  def stream(tokens, &b); end

  private

  # A performance-oriented helper method to escape `&`, `<` and `>` for the rendered
  # HTML from this formatter.
  #
  # `String#gsub` will always return a new string instance irrespective of whether
  # a substitution occurs. This method however invokes `String#gsub` only if
  # a substitution is imminent.
  #
  # Returns either the given `value` argument string as is or a new string with the
  # special characters replaced with their escaped counterparts.
  #
  # source://rouge//lib/rouge/formatters/html.rb#48
  def escape_special_html_chars(value); end
end

# source://rouge//lib/rouge/formatters/html.rb#32
Rouge::Formatters::HTML::TABLE_FOR_ESCAPE_HTML = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/formatters/html_inline.rb#6
class Rouge::Formatters::HTMLInline < ::Rouge::Formatters::HTML
  # @return [HTMLInline] a new instance of HTMLInline
  #
  # source://rouge//lib/rouge/formatters/html_inline.rb#9
  def initialize(theme); end

  # source://rouge//lib/rouge/formatters/html_inline.rb#21
  def safe_span(tok, safe_val); end
end

# Transforms a token stream into HTML output.
#
# source://rouge//lib/rouge/formatters/html_legacy.rb#10
class Rouge::Formatters::HTMLLegacy < ::Rouge::Formatter
  # Initialize with options.
  #
  # If `:inline_theme` is given, then instead of rendering the
  # tokens as <span> tags with CSS classes, the styles according to
  # the given theme will be inlined in "style" attributes.  This is
  # useful for formats in which stylesheets are not available.
  #
  # Content will be wrapped in a tag (`div` if tableized, `pre` if
  # not) with the given `:css_class` unless `:wrap` is set to `false`.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash] a customizable set of options
  # @return [HTMLLegacy] a new instance of HTMLLegacy
  #
  # source://rouge//lib/rouge/formatters/html_legacy.rb#27
  def initialize(opts = T.unsafe(nil)); end

  # @yield the html output.
  #
  # source://rouge//lib/rouge/formatters/html_legacy.rb#40
  def stream(tokens, &b); end
end

# source://rouge//lib/rouge/formatters/html_line_highlighter.rb#6
class Rouge::Formatters::HTMLLineHighlighter < ::Rouge::Formatter
  # @return [HTMLLineHighlighter] a new instance of HTMLLineHighlighter
  #
  # source://rouge//lib/rouge/formatters/html_line_highlighter.rb#9
  def initialize(delegate, opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/formatters/html_line_highlighter.rb#15
  def stream(tokens); end
end

# source://rouge//lib/rouge/formatters/html_line_table.rb#6
class Rouge::Formatters::HTMLLineTable < ::Rouge::Formatter
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param formatter [Rouge::Formatters::Formatter] An instance of a
  #   `Rouge::Formatters::HTML` or `Rouge::Formatters::HTMLInline`
  # @param opts [Hash] options for HTMLLineTable instance.
  # @return [HTMLLineTable] a new instance of HTMLLineTable
  #
  # source://rouge//lib/rouge/formatters/html_line_table.rb#24
  def initialize(formatter, opts = T.unsafe(nil)); end

  # @yield [buffer.join]
  #
  # source://rouge//lib/rouge/formatters/html_line_table.rb#34
  def stream(tokens, &b); end
end

# source://rouge//lib/rouge/formatters/html_linewise.rb#6
class Rouge::Formatters::HTMLLinewise < ::Rouge::Formatter
  # @return [HTMLLinewise] a new instance of HTMLLinewise
  #
  # source://rouge//lib/rouge/formatters/html_linewise.rb#7
  def initialize(formatter, opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/formatters/html_linewise.rb#13
  def stream(tokens, &b); end
end

# source://rouge//lib/rouge/formatters/html_pygments.rb#5
class Rouge::Formatters::HTMLPygments < ::Rouge::Formatter
  # @return [HTMLPygments] a new instance of HTMLPygments
  #
  # source://rouge//lib/rouge/formatters/html_pygments.rb#6
  def initialize(inner, css_class = T.unsafe(nil)); end

  # @yield [%(<div class="highlight"><pre class="#{@css_class}"><code>)]
  #
  # source://rouge//lib/rouge/formatters/html_pygments.rb#11
  def stream(tokens, &b); end
end

# source://rouge//lib/rouge/formatters/html_table.rb#6
class Rouge::Formatters::HTMLTable < ::Rouge::Formatter
  # @return [HTMLTable] a new instance of HTMLTable
  #
  # source://rouge//lib/rouge/formatters/html_table.rb#9
  def initialize(inner, opts = T.unsafe(nil)); end

  # @yield [buffer.join]
  #
  # source://rouge//lib/rouge/formatters/html_table.rb#23
  def stream(tokens, &b); end

  # @yield [%(#{scope} .rouge-table { border-spacing: 0 })]
  #
  # source://rouge//lib/rouge/formatters/html_table.rb#18
  def style(scope); end
end

# A formatter which renders nothing.
#
# source://rouge//lib/rouge/formatters/null.rb#7
class Rouge::Formatters::Null < ::Rouge::Formatter
  # @return [Null] a new instance of Null
  #
  # source://rouge//lib/rouge/formatters/null.rb#10
  def initialize(*_arg0); end

  # source://rouge//lib/rouge/formatters/null.rb#13
  def stream(tokens, &b); end
end

# A formatter for 256-color terminals
#
# source://rouge//lib/rouge/formatters/terminal256.rb#7
class Rouge::Formatters::Terminal256 < ::Rouge::Formatter
  # @param theme [Hash, Rouge::Theme] the theme to render with.
  # @return [Terminal256] a new instance of Terminal256
  #
  # source://rouge//lib/rouge/formatters/terminal256.rb#15
  def initialize(theme = T.unsafe(nil)); end

  # private
  #
  # source://rouge//lib/rouge/formatters/terminal256.rb#173
  def escape_sequence(token); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#184
  def get_style(token); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#180
  def make_escape_sequence(style); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#25
  def stream(tokens, &b); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#190
  def text_style; end

  # @private
  #
  # source://rouge//lib/rouge/formatters/terminal256.rb#11
  def theme; end
end

# source://rouge//lib/rouge/formatters/terminal256.rb#31
class Rouge::Formatters::Terminal256::EscapeSequence
  # @return [EscapeSequence] a new instance of EscapeSequence
  #
  # source://rouge//lib/rouge/formatters/terminal256.rb#33
  def initialize(style); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#80
  def bg; end

  # source://rouge//lib/rouge/formatters/terminal256.rb#75
  def fg; end

  # source://rouge//lib/rouge/formatters/terminal256.rb#105
  def reset_string; end

  # @yield [style_string]
  #
  # source://rouge//lib/rouge/formatters/terminal256.rb#86
  def stream_value(val, &b); end

  # Returns the value of attribute style.
  #
  # source://rouge//lib/rouge/formatters/terminal256.rb#32
  def style; end

  # source://rouge//lib/rouge/formatters/terminal256.rb#93
  def style_string; end

  private

  # source://rouge//lib/rouge/formatters/terminal256.rb#117
  def escape(attrs); end

  class << self
    # source://rouge//lib/rouge/formatters/terminal256.rb#144
    def closest_color(r, g, b); end

    # source://rouge//lib/rouge/formatters/terminal256.rb#122
    def color_index(color); end

    # source://rouge//lib/rouge/formatters/terminal256.rb#127
    def get_rgb(color); end

    # source://rouge//lib/rouge/formatters/terminal256.rb#37
    def xterm_colors; end
  end
end

# max distance between two colors, #000000 to #ffffff
#
# source://rouge//lib/rouge/formatters/terminal256.rb#142
Rouge::Formatters::Terminal256::EscapeSequence::MAX_DISTANCE = T.let(T.unsafe(nil), Integer)

# source://rouge//lib/rouge/formatters/terminal256.rb#165
class Rouge::Formatters::Terminal256::Unescape < ::Rouge::Formatters::Terminal256::EscapeSequence
  # @return [Unescape] a new instance of Unescape
  #
  # source://rouge//lib/rouge/formatters/terminal256.rb#166
  def initialize(*_arg0); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#168
  def reset_string(*_arg0); end

  # @yield [val]
  #
  # source://rouge//lib/rouge/formatters/terminal256.rb#169
  def stream_value(val); end

  # source://rouge//lib/rouge/formatters/terminal256.rb#167
  def style_string(*_arg0); end
end

# source://rouge//lib/rouge/formatters/terminal_truecolor.rb#5
class Rouge::Formatters::TerminalTruecolor < ::Rouge::Formatters::Terminal256
  # source://rouge//lib/rouge/formatters/terminal_truecolor.rb#32
  def make_escape_sequence(style); end
end

# source://rouge//lib/rouge/formatters/terminal_truecolor.rb#8
class Rouge::Formatters::TerminalTruecolor::TruecolorEscapeSequence < ::Rouge::Formatters::Terminal256::EscapeSequence
  # source://rouge//lib/rouge/formatters/terminal_truecolor.rb#19
  def get_rgb(color); end

  # source://rouge//lib/rouge/formatters/terminal_truecolor.rb#9
  def style_string; end
end

# source://rouge//lib/rouge/formatters/tex.rb#6
class Rouge::Formatters::Tex < ::Rouge::Formatter
  # @return [Tex] a new instance of Tex
  #
  # source://rouge//lib/rouge/formatters/tex.rb#33
  def initialize(opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/formatters/tex.rb#37
  def escape_tex(str); end

  # Special handling for leading spaces, since they may be gobbled
  # by a previous command.  We replace all initial spaces with
  # \hphantom{xxxx}, which renders an empty space equal to the size
  # of the x's.
  #
  # @yield ["\\hphantom{#{'x' * leading}}"]
  #
  # source://rouge//lib/rouge/formatters/tex.rb#74
  def hphantom_tag(tok, val); end

  # source://rouge//lib/rouge/formatters/tex.rb#64
  def render_line(line, &b); end

  # @yield ["\\begin{#{@prefix}*}%\n"]
  #
  # source://rouge//lib/rouge/formatters/tex.rb#41
  def stream(tokens, &b); end

  # source://rouge//lib/rouge/formatters/tex.rb#81
  def tag(tok, val); end
end

# A map of TeX escape characters.
# Newlines are handled specially by using #token_lines
# spaces are preserved as long as they aren't at the beginning
# of a line. see #tag_first for our initial-space strategy
#
# source://rouge//lib/rouge/formatters/tex.rb#13
Rouge::Formatters::Tex::ESCAPE = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/formatters/tex.rb#31
Rouge::Formatters::Tex::ESCAPE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/guesser.rb#4
class Rouge::Guesser
  # source://rouge//lib/rouge/guesser.rb#33
  def collect_best(lexers, opts = T.unsafe(nil), &scorer); end

  # source://rouge//lib/rouge/guesser.rb#53
  def filter(lexers); end

  class << self
    # source://rouge//lib/rouge/guesser.rb#14
    def guess(guessers, lexers); end
  end
end

# source://rouge//lib/rouge/guesser.rb#5
class Rouge::Guesser::Ambiguous < ::StandardError
  # @return [Ambiguous] a new instance of Ambiguous
  #
  # source://rouge//lib/rouge/guesser.rb#7
  def initialize(alternatives); end

  # Returns the value of attribute alternatives.
  #
  # source://rouge//lib/rouge/guesser.rb#6
  def alternatives; end

  # source://rouge//lib/rouge/guesser.rb#9
  def message; end
end

# source://rouge//lib/rouge/guessers/util.rb#4
module Rouge::Guessers; end

# source://rouge//lib/rouge/guessers/disambiguation.rb#5
class Rouge::Guessers::Disambiguation < ::Rouge::Guesser
  include ::Rouge::Guessers::Util
  include ::Rouge::Lexers

  # @return [Disambiguation] a new instance of Disambiguation
  #
  # source://rouge//lib/rouge/guessers/disambiguation.rb#9
  def initialize(filename, source); end

  # @return [Boolean]
  #
  # source://rouge//lib/rouge/guessers/disambiguation.rb#30
  def contains?(text); end

  # source://rouge//lib/rouge/guessers/disambiguation.rb#14
  def filter(lexers); end

  # @return [Boolean]
  #
  # source://rouge//lib/rouge/guessers/disambiguation.rb#34
  def matches?(re); end

  class << self
    # source://rouge//lib/rouge/guessers/disambiguation.rb#39
    def disambiguate(*patterns, &decider); end

    # source://rouge//lib/rouge/guessers/disambiguation.rb#43
    def disambiguators; end
  end
end

# source://rouge//lib/rouge/guessers/disambiguation.rb#47
class Rouge::Guessers::Disambiguation::Disambiguator
  include ::Rouge::Guessers::Util

  # @return [Disambiguator] a new instance of Disambiguator
  #
  # source://rouge//lib/rouge/guessers/disambiguation.rb#50
  def initialize(patterns, &decider); end

  # source://rouge//lib/rouge/guessers/disambiguation.rb#55
  def decide!(guesser); end

  # @return [Boolean]
  #
  # source://rouge//lib/rouge/guessers/disambiguation.rb#64
  def match?(filename); end
end

# source://rouge//lib/rouge/guessers/filename.rb#5
class Rouge::Guessers::Filename < ::Rouge::Guesser
  # @return [Filename] a new instance of Filename
  #
  # source://rouge//lib/rouge/guessers/filename.rb#7
  def initialize(filename); end

  # returns a list of lexers that match the given filename with
  # equal specificity (i.e. number of wildcards in the pattern).
  # This helps disambiguate between, e.g. the Nginx lexer, which
  # matches `nginx.conf`, and the Conf lexer, which matches `*.conf`.
  # In this case, nginx will win because the pattern has no wildcards,
  # while `*.conf` has one.
  #
  # source://rouge//lib/rouge/guessers/filename.rb#17
  def filter(lexers); end

  # Returns the value of attribute fname.
  #
  # source://rouge//lib/rouge/guessers/filename.rb#6
  def fname; end
end

# This class allows for custom behavior
# with glob -> lexer name mappings
#
# source://rouge//lib/rouge/guessers/glob_mapping.rb#7
class Rouge::Guessers::GlobMapping < ::Rouge::Guesser
  include ::Rouge::Guessers::Util

  # @return [GlobMapping] a new instance of GlobMapping
  #
  # source://rouge//lib/rouge/guessers/glob_mapping.rb#26
  def initialize(glob_map, filename); end

  # Returns the value of attribute filename.
  #
  # source://rouge//lib/rouge/guessers/glob_mapping.rb#25
  def filename; end

  # source://rouge//lib/rouge/guessers/glob_mapping.rb#31
  def filter(lexers); end

  # Returns the value of attribute glob_map.
  #
  # source://rouge//lib/rouge/guessers/glob_mapping.rb#25
  def glob_map; end

  class << self
    # source://rouge//lib/rouge/guessers/glob_mapping.rb#10
    def by_pairs(mapping, filename); end
  end
end

# source://rouge//lib/rouge/guessers/mimetype.rb#5
class Rouge::Guessers::Mimetype < ::Rouge::Guesser
  # @return [Mimetype] a new instance of Mimetype
  #
  # source://rouge//lib/rouge/guessers/mimetype.rb#7
  def initialize(mimetype); end

  # source://rouge//lib/rouge/guessers/mimetype.rb#11
  def filter(lexers); end

  # Returns the value of attribute mimetype.
  #
  # source://rouge//lib/rouge/guessers/mimetype.rb#6
  def mimetype; end
end

# source://rouge//lib/rouge/guessers/modeline.rb#5
class Rouge::Guessers::Modeline < ::Rouge::Guesser
  include ::Rouge::Guessers::Util

  # @return [Modeline] a new instance of Modeline
  #
  # source://rouge//lib/rouge/guessers/modeline.rb#23
  def initialize(source, opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/guessers/modeline.rb#28
  def filter(lexers); end
end

# [jneen] regexen stolen from linguist
#
# source://rouge//lib/rouge/guessers/modeline.rb#9
Rouge::Guessers::Modeline::EMACS_MODELINE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/guessers/modeline.rb#21
Rouge::Guessers::Modeline::MODELINES = T.let(T.unsafe(nil), Array)

# First form vim modeline
# [text]{white}{vi:|vim:|ex:}[white]{options}
# ex: 'vim: syntax=ruby'
#
# source://rouge//lib/rouge/guessers/modeline.rb#14
Rouge::Guessers::Modeline::VIM_MODELINE_1 = T.let(T.unsafe(nil), Regexp)

# Second form vim modeline (compatible with some versions of Vi)
# [text]{white}{vi:|vim:|Vim:|ex:}[white]se[t] {options}:[text]
# ex: 'vim set syntax=ruby:'
#
# source://rouge//lib/rouge/guessers/modeline.rb#19
Rouge::Guessers::Modeline::VIM_MODELINE_2 = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/guessers/source.rb#5
class Rouge::Guessers::Source < ::Rouge::Guesser
  include ::Rouge::Guessers::Util

  # @return [Source] a new instance of Source
  #
  # source://rouge//lib/rouge/guessers/source.rb#9
  def initialize(source); end

  # source://rouge//lib/rouge/guessers/source.rb#13
  def filter(lexers); end

  # Returns the value of attribute source.
  #
  # source://rouge//lib/rouge/guessers/source.rb#8
  def source; end
end

# source://rouge//lib/rouge/guessers/util.rb#5
module Rouge::Guessers::Util
  # @param source [String, IO]
  # @return [String]
  #
  # source://rouge//lib/rouge/guessers/util.rb#23
  def get_source(source); end

  # source://rouge//lib/rouge/guessers/util.rb#17
  def test_glob(pattern, path); end
end

# source://rouge//lib/rouge/guessers/util.rb#6
module Rouge::Guessers::Util::SourceNormalizer
  class << self
    # @param source [String, nil]
    # @return [String, nil]
    #
    # source://rouge//lib/rouge/guessers/util.rb#12
    def normalize(source); end
  end
end

# source://rouge//lib/rouge/guessers/util.rb#7
Rouge::Guessers::Util::SourceNormalizer::UTF8_BOM = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/guessers/util.rb#8
Rouge::Guessers::Util::SourceNormalizer::UTF8_BOM_RE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/theme.rb#136
module Rouge::HasModes
  # source://rouge//lib/rouge/theme.rb#144
  def get_mode(mode); end

  # source://rouge//lib/rouge/theme.rb#137
  def mode(arg = T.unsafe(nil)); end

  # source://rouge//lib/rouge/theme.rb#156
  def mode!(arg); end

  # source://rouge//lib/rouge/theme.rb#151
  def set_mode!(mode); end
end

# shared methods for some indentation-sensitive lexers
#
# source://rouge//lib/rouge/util.rb#68
module Rouge::Indentation
  # handle a single indented line
  #
  # source://rouge//lib/rouge/util.rb#83
  def indentation(indent_str); end

  # source://rouge//lib/rouge/util.rb#69
  def reset!; end

  # push a state for the next indented block
  #
  # source://rouge//lib/rouge/util.rb#75
  def starts_block(block_state); end
end

# source://rouge//lib/rouge/util.rb#5
class Rouge::InheritableHash < ::Hash
  # @return [InheritableHash] a new instance of InheritableHash
  #
  # source://rouge//lib/rouge/util.rb#6
  def initialize(parent = T.unsafe(nil)); end

  # source://rouge//lib/rouge/util.rb#10
  def [](k); end

  # source://rouge//lib/rouge/util.rb#25
  def each(&b); end

  # @return [Boolean]
  #
  # source://rouge//lib/rouge/util.rb#21
  def include?(k); end

  # source://rouge//lib/rouge/util.rb#32
  def keys; end

  def own_keys; end

  # source://rouge//lib/rouge/util.rb#17
  def parent; end
end

# source://rouge//lib/rouge/util.rb#39
class Rouge::InheritableList
  include ::Enumerable

  # @return [InheritableList] a new instance of InheritableList
  #
  # source://rouge//lib/rouge/util.rb#42
  def initialize(parent = T.unsafe(nil)); end

  # source://rouge//lib/rouge/util.rb#61
  def <<(o); end

  # source://rouge//lib/rouge/util.rb#50
  def each(&b); end

  # source://rouge//lib/rouge/util.rb#57
  def own_entries; end

  # source://rouge//lib/rouge/util.rb#46
  def parent; end

  # source://rouge//lib/rouge/util.rb#61
  def push(o); end
end

# cache value in a constant since `__dir__` allocates a new string
# on every call.
#
# source://rouge//lib/rouge.rb#11
Rouge::LIB_DIR = T.let(T.unsafe(nil), String)

# A lexer transforms text into a stream of `[token, chunk]` pairs.
#
# @abstract
#
# source://rouge//lib/rouge/lexer.rb#12
class Rouge::Lexer
  include ::Rouge::Token::Tokens

  # Create a new lexer with the given options.  Individual lexers may
  # specify extra options.  The only current globally accepted option
  # is `:debug`.
  #
  # @option opts
  # @param opts [Hash] a customizable set of options
  # @return [Lexer] a new instance of Lexer
  #
  # source://rouge//lib/rouge/lexer.rb#323
  def initialize(opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/lexer.rb#338
  def as_bool(val); end

  # source://rouge//lib/rouge/lexer.rb#366
  def as_lexer(val); end

  # source://rouge//lib/rouge/lexer.rb#355
  def as_list(val); end

  # source://rouge//lib/rouge/lexer.rb#349
  def as_string(val); end

  # source://rouge//lib/rouge/lexer.rb#379
  def as_token(val); end

  # source://rouge//lib/rouge/lexer.rb#389
  def bool_option(name, &default); end

  # Continue the lex from the the current state without resetting
  #
  # source://rouge//lib/rouge/lexer.rb#474
  def continue_lex(string, &b); end

  # source://rouge//lib/rouge/lexer.rb#415
  def hash_option(name, defaults, &val_cast); end

  # Given a string, yield [token, chunk] pairs.  If no block is given,
  # an enumerator is returned.
  #
  # @note The use of :continue => true has been deprecated. A warning is
  #   issued if run with `$VERBOSE` set to true.
  # @note The use of arbitrary `opts` has never been supported, but we
  #   previously ignored them with no error. We now warn unconditionally.
  # @option opts
  # @param opts [Hash] a customizable set of options
  #
  # source://rouge//lib/rouge/lexer.rb#451
  def lex(string, opts = T.unsafe(nil), &b); end

  # source://rouge//lib/rouge/lexer.rb#403
  def lexer_option(name, &default); end

  # source://rouge//lib/rouge/lexer.rb#407
  def list_option(name, &default); end

  # -*- instance methods -*- #
  #
  # source://rouge//lib/rouge/lexer.rb#313
  def options; end

  # Called after each lex is finished.  The default implementation
  # is a noop.
  #
  # @abstract
  #
  # source://rouge//lib/rouge/lexer.rb#437
  def reset!; end

  # Yield `[token, chunk]` pairs, given a prepared input stream.  This
  # must be implemented.
  #
  # @abstract
  # @param stream [StringScanner] the stream
  #
  # source://rouge//lib/rouge/lexer.rb#508
  def stream_tokens(stream, &b); end

  # source://rouge//lib/rouge/lexer.rb#399
  def string_option(name, &default); end

  # delegated to {Lexer.tag}
  #
  # source://rouge//lib/rouge/lexer.rb#497
  def tag; end

  # source://rouge//lib/rouge/lexer.rb#411
  def token_option(name, &default); end

  # Returns a new lexer with the given options set. Useful for e.g. setting
  # debug flags post hoc, or providing global overrides for certain options
  #
  # source://rouge//lib/rouge/lexer.rb#332
  def with(opts = T.unsafe(nil)); end

  class << self
    # Used to specify alternate names this lexer class may be found by.
    #
    # @example
    #   class Erb < Lexer
    #   tag 'erb'
    #   aliases 'eruby', 'rhtml'
    #   end
    #
    #   Lexer.find('eruby') # => Erb
    #
    # source://rouge//lib/rouge/lexer.rb#261
    def aliases(*args); end

    # @return a list of all lexers.
    #
    # source://rouge//lib/rouge/lexer.rb#141
    def all; end

    # @private
    # @raise [EncodingError]
    #
    # source://rouge//lib/rouge/lexer.rb#295
    def assert_utf8!(str); end

    # In case #continue_lex is called statically, we simply
    # begin a new lex from the beginning, since there is no state.
    #
    # @see #continue_lex
    #
    # source://rouge//lib/rouge/lexer.rb#30
    def continue_lex(*a, &b); end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexer.rb#215
    def debug_enabled?; end

    # Specify or get a small demo string for this lexer
    #
    # source://rouge//lib/rouge/lexer.rb#134
    def demo(arg = T.unsafe(nil)); end

    # Specify or get the path name containing a small demo for
    # this lexer (can be overriden by {demo}).
    #
    # source://rouge//lib/rouge/lexer.rb#127
    def demo_file(arg = T.unsafe(nil)); end

    # Specify or get this lexer's description.
    #
    # source://rouge//lib/rouge/lexer.rb#109
    def desc(arg = T.unsafe(nil)); end

    # Return true if there is an in-text indication (such as a shebang
    # or DOCTYPE declaration) that this lexer should be used.
    #
    # @abstract
    # @param text [TextAnalyzer] the text to be analyzed, with a couple of handy methods on it,
    #   like {TextAnalyzer#shebang?} and {TextAnalyzer#doctype?}
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexer.rb#520
    def detect?(text); end

    # Determine if a lexer has a method named +:detect?+ defined in its
    # singleton class.
    #
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexer.rb#221
    def detectable?; end

    # source://rouge//lib/rouge/lexer.rb#211
    def disable_debug!; end

    # source://rouge//lib/rouge/lexer.rb#207
    def enable_debug!; end

    # Specify a list of filename globs associated with this lexer.
    #
    # If a filename glob is associated with more than one lexer, this can
    # cause a Guesser::Ambiguous error to be raised in various guessing
    # methods. These errors can be avoided by disambiguation. Filename globs
    # are disambiguated in one of two ways. Either the lexer will define a
    # `self.detect?` method (intended for use with shebangs and doctypes) or a
    # manual rule will be specified in Guessers::Disambiguation.
    #
    # @example
    #   class Ruby < Lexer
    #   filenames '*.rb', '*.ruby', 'Gemfile', 'Rakefile'
    #   end
    #
    # source://rouge//lib/rouge/lexer.rb#280
    def filenames(*fnames); end

    # Given a name in string, return the correct lexer class.
    #
    # @param name [String]
    # @return [Class<Rouge::Lexer>, nil]
    #
    # source://rouge//lib/rouge/lexer.rb#37
    def find(name); end

    # Find a lexer, with fancy shiny features.
    #
    # * The string you pass can include CGI-style options
    #
    #     Lexer.find_fancy('erb?parent=tex')
    #
    # * You can pass the special name 'guess' so we guess for you,
    #   and you can pass a second argument of the code to guess by
    #
    #     Lexer.find_fancy('guess', "#!/bin/bash\necho Hello, world")
    #
    #   If the code matches more than one lexer then Guesser::Ambiguous
    #   is raised.
    #
    # This is used in the Redcarpet plugin as well as Rouge's own
    # markdown lexer for highlighting internal code blocks.
    #
    # source://rouge//lib/rouge/lexer.rb#94
    def find_fancy(str, code = T.unsafe(nil), default_options = T.unsafe(nil)); end

    # Guess which lexer to use based on a hash of info.
    #
    # @option info
    # @option info
    # @option info
    # @param info [Hash] a customizable set of options
    # @param fallback [Proc] called if multiple lexers are detected.
    #   If omitted, Guesser::Ambiguous is raised.
    # @return [Class<Rouge::Lexer>]
    # @see Lexer.detect?
    # @see Lexer.guesses
    #
    # source://rouge//lib/rouge/lexer.rb#182
    def guess(info = T.unsafe(nil), &fallback); end

    # source://rouge//lib/rouge/lexer.rb#199
    def guess_by_filename(fname); end

    # source://rouge//lib/rouge/lexer.rb#195
    def guess_by_mimetype(mt); end

    # source://rouge//lib/rouge/lexer.rb#203
    def guess_by_source(source); end

    # Guess which lexer to use based on a hash of info.
    #
    # This accepts the same arguments as Lexer.guess, but will never throw
    # an error.  It will return a (possibly empty) list of potential lexers
    # to use.
    #
    # source://rouge//lib/rouge/lexer.rb#150
    def guesses(info = T.unsafe(nil)); end

    # Lexes `stream` with the given options.  The lex is delegated to a
    # new instance.
    #
    # @see #lex
    #
    # source://rouge//lib/rouge/lexer.rb#22
    def lex(stream, opts = T.unsafe(nil), &b); end

    # Same as ::find_fancy, except instead of returning an instantiated
    # lexer, returns a pair of [lexer_class, options], so that you can
    # modify or provide additional options to the lexer.
    #
    # Please note: the lexer class might be nil!
    #
    # source://rouge//lib/rouge/lexer.rb#46
    def lookup_fancy(str, code = T.unsafe(nil), default_options = T.unsafe(nil)); end

    # Specify a list of mimetypes associated with this lexer.
    #
    # @example
    #   class Html < Lexer
    #   mimetypes 'text/html', 'application/xhtml+xml'
    #   end
    #
    # source://rouge//lib/rouge/lexer.rb#290
    def mimetypes(*mts); end

    # source://rouge//lib/rouge/lexer.rb#121
    def option(name, desc); end

    # source://rouge//lib/rouge/lexer.rb#117
    def option_docs; end

    # Used to specify or get the canonical name of this lexer class.
    #
    # @example
    #   class MyLexer < Lexer
    #   tag 'foo'
    #   end
    #
    #   MyLexer.tag # => 'foo'
    #
    #   Lexer.find('foo') # => MyLexer
    #
    # source://rouge//lib/rouge/lexer.rb#245
    def tag(t = T.unsafe(nil)); end

    # Specify or get this lexer's title. Meant to be human-readable.
    #
    # source://rouge//lib/rouge/lexer.rb#101
    def title(t = T.unsafe(nil)); end

    protected

    # @private
    #
    # source://rouge//lib/rouge/lexer.rb#228
    def register(name, lexer); end

    private

    # source://rouge//lib/rouge/lexer.rb#306
    def registry; end
  end
end

# source://rouge//lib/rouge/lexer.rb#525
module Rouge::Lexers
  class << self
    # source://rouge//lib/rouge/lexer.rb#529
    def load_lexer(relpath); end
  end
end

# source://rouge//lib/rouge/lexers/abap.rb#8
class Rouge::Lexers::ABAP < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/abap.rb#148
    def builtins; end

    # source://rouge//lib/rouge/lexers/abap.rb#15
    def keywords; end

    # source://rouge//lib/rouge/lexers/abap.rb#178
    def new_keywords; end

    # source://rouge//lib/rouge/lexers/abap.rb#171
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/apiblueprint.rb#7
class Rouge::Lexers::APIBlueprint < ::Rouge::Lexers::Markdown; end

# source://rouge//lib/rouge/lexers/actionscript.rb#6
class Rouge::Lexers::Actionscript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/actionscript.rb#100
    def builtins; end

    # source://rouge//lib/rouge/lexers/actionscript.rb#96
    def constants; end

    # source://rouge//lib/rouge/lexers/actionscript.rb#84
    def declarations; end

    # source://rouge//lib/rouge/lexers/actionscript.rb#76
    def keywords; end

    # source://rouge//lib/rouge/lexers/actionscript.rb#88
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/ada.rb#6
class Rouge::Lexers::Ada < ::Rouge::RegexLexer
  class << self
    # Return a hash mapping lower-case identifiers to token classes.
    #
    # source://rouge//lib/rouge/lexers/ada.rb#23
    def idents; end
  end
end

# source://rouge//lib/rouge/lexers/ada.rb#20
Rouge::Lexers::Ada::EXP = T.let(T.unsafe(nil), Regexp)

# Ada identifiers are Unicode with underscores only allowed as separators.
#
# source://rouge//lib/rouge/lexers/ada.rb#15
Rouge::Lexers::Ada::ID = T.let(T.unsafe(nil), Regexp)

# Numerals can also contain underscores.
#
# source://rouge//lib/rouge/lexers/ada.rb#18
Rouge::Lexers::Ada::NUM = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/ada.rb#19
Rouge::Lexers::Ada::XNUM = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/apache.rb#7
class Rouge::Lexers::Apache < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/apache.rb#30
  def name_for_token(token, tktype); end

  class << self
    # self-modifying method that loads the keywords file
    #
    # source://rouge//lib/rouge/lexers/apache.rb#15
    def directives; end

    # source://rouge//lib/rouge/lexers/apache.rb#20
    def sections; end

    # source://rouge//lib/rouge/lexers/apache.rb#25
    def values; end
  end
end

# source://rouge//lib/rouge/lexers/apex.rb#6
class Rouge::Lexers::Apex < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/apex.rb#44
    def constants; end

    # source://rouge//lib/rouge/lexers/apex.rb#22
    def declarations; end

    # source://rouge//lib/rouge/lexers/apex.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/apex.rb#30
    def soql; end

    # source://rouge//lib/rouge/lexers/apex.rb#38
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/apple_script.rb#6
class Rouge::Lexers::AppleScript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/apple_script.rb#30
    def builtins; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#23
    def classes; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#42
    def commands; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#87
    def controls; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#95
    def declarations; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#35
    def handler_params; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#17
    def literals; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#68
    def operators; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#60
    def references; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#99
    def reserved; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#103
    def studio_classes; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#169
    def studio_commands; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#122
    def studio_events; end

    # source://rouge//lib/rouge/lexers/apple_script.rb#183
    def studio_properties; end
  end
end

# source://rouge//lib/rouge/lexers/armasm.rb#6
class Rouge::Lexers::ArmAsm < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/armasm.rb#44
    def builtin; end

    # source://rouge//lib/rouge/lexers/armasm.rb#18
    def file_directive; end

    # source://rouge//lib/rouge/lexers/armasm.rb#24
    def general_directive; end

    # source://rouge//lib/rouge/lexers/armasm.rb#52
    def operator; end

    # source://rouge//lib/rouge/lexers/armasm.rb#12
    def preproc_keyword; end

    # source://rouge//lib/rouge/lexers/armasm.rb#37
    def shift_or_condition; end
  end
end

# source://rouge//lib/rouge/lexers/augeas.rb#6
class Rouge::Lexers::Augeas < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/augeas.rb#15
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/awk.rb#6
class Rouge::Lexers::Awk < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/awk.rb#42
    def builtins; end

    # source://rouge//lib/rouge/lexers/awk.rb#35
    def constants; end

    # source://rouge//lib/rouge/lexers/awk.rb#27
    def declarations; end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/awk.rb#14
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/awk.rb#20
    def keywords; end

    # source://rouge//lib/rouge/lexers/awk.rb#31
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexer.rb#526
Rouge::Lexers::BASE_DIR = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/bbcbasic.rb#6
class Rouge::Lexers::BBCBASIC < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/bbcbasic.rb#45
    def constant; end

    # source://rouge//lib/rouge/lexers/bbcbasic.rb#18
    def function; end

    # source://rouge//lib/rouge/lexers/bbcbasic.rb#39
    def operator; end

    # source://rouge//lib/rouge/lexers/bbcbasic.rb#12
    def punctuation; end

    # source://rouge//lib/rouge/lexers/bbcbasic.rb#28
    def statement; end
  end
end

# source://rouge//lib/rouge/lexers/biml.rb#7
class Rouge::Lexers::BIML < ::Rouge::Lexers::XML
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/biml.rb#13
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/bpf.rb#6
class Rouge::Lexers::BPF < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/bpf.rb#15
Rouge::Lexers::BPF::MISC_KEYWORDS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/bpf.rb#11
Rouge::Lexers::BPF::TYPE_KEYWORDS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/batchfile.rb#6
class Rouge::Lexers::Batchfile < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/batchfile.rb#73
    def attributes; end

    # source://rouge//lib/rouge/lexers/batchfile.rb#35
    def builtin_commands; end

    # source://rouge//lib/rouge/lexers/batchfile.rb#28
    def devices; end

    # source://rouge//lib/rouge/lexers/batchfile.rb#16
    def keywords; end

    # source://rouge//lib/rouge/lexers/batchfile.rb#22
    def operator_words; end

    # source://rouge//lib/rouge/lexers/batchfile.rb#48
    def other_commands; end
  end
end

# source://rouge//lib/rouge/lexers/bibtex.rb#9
class Rouge::Lexers::BibTeX < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/brainfuck.rb#6
class Rouge::Lexers::Brainfuck < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/brightscript.rb#6
class Rouge::Lexers::Brightscript < ::Rouge::RegexLexer
  class << self
    # Scene graph components configured as builtins. See BrightScript component documentation e.g.
    # https://developer.roku.com/en-ca/docs/references/brightscript/components/roappinfo.md
    #
    # source://rouge//lib/rouge/lexers/brightscript.rb#63
    def builtins; end

    # https://developer.roku.com/en-ca/docs/references/brightscript/language/reserved-words.md
    #
    # source://rouge//lib/rouge/lexers/brightscript.rb#29
    def keyword_reserved; end

    # These keywords are present in BrightScript, but not supported in standard .brs files
    #
    # source://rouge//lib/rouge/lexers/brightscript.rb#40
    def keyword_reserved_unsupported; end

    # https://developer.roku.com/en-ca/docs/references/brightscript/language/expressions-variables-types.md
    #
    # source://rouge//lib/rouge/lexers/brightscript.rb#47
    def keyword_type; end

    # https://developer.roku.com/en-ca/docs/references/brightscript/language/global-utility-functions.md
    # https://developer.roku.com/en-ca/docs/references/brightscript/language/global-string-functions.md
    # https://developer.roku.com/en-ca/docs/references/brightscript/language/global-math-functions.md
    #
    # source://rouge//lib/rouge/lexers/brightscript.rb#16
    def name_builtin; end

    # https://developer.roku.com/en-ca/docs/references/brightscript/language/expressions-variables-types.md#operators
    #
    # source://rouge//lib/rouge/lexers/brightscript.rb#55
    def operator_word; end
  end
end

# source://rouge//lib/rouge/lexers/bsl.rb#6
class Rouge::Lexers::Bsl < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/bsl.rb#30
Rouge::Lexers::Bsl::BUILTINS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/bsl.rb#12
Rouge::Lexers::Bsl::KEYWORDS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/c.rb#6
class Rouge::Lexers::C < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/c.rb#59
    def builtins; end

    # source://rouge//lib/rouge/lexers/c.rb#18
    def keywords; end

    # source://rouge//lib/rouge/lexers/c.rb#29
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/c.rb#50
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/cmhg.rb#6
class Rouge::Lexers::CMHG < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/cmhg.rb#12
    def preproc_keyword; end
  end
end

# source://rouge//lib/rouge/lexers/cmake.rb#6
class Rouge::Lexers::CMake < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/cmake.rb#14
Rouge::Lexers::CMake::BRACKET_OPEN = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/cmake.rb#24
Rouge::Lexers::CMake::BUILTIN_COMMANDS = T.let(T.unsafe(nil), Set)

# source://rouge//lib/rouge/lexers/cmake.rb#13
Rouge::Lexers::CMake::SPACE = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/cmake.rb#16
Rouge::Lexers::CMake::STATES_MAP = T.let(T.unsafe(nil), Hash)

# source://rouge//lib/rouge/lexers/css.rb#6
class Rouge::Lexers::CSS < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/css.rb#19
    def attributes; end

    # source://rouge//lib/rouge/lexers/css.rb#120
    def builtins; end

    # source://rouge//lib/rouge/lexers/css.rb#151
    def constants; end

    # source: http://www.w3.org/TR/CSS21/syndata.html#vendor-keyword-history
    #
    # source://rouge//lib/rouge/lexers/css.rb#181
    def vendor_prefixes; end
  end
end

# source://rouge//lib/rouge/lexers/csvs.rb#6
class Rouge::Lexers::CSVS < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/csharp.rb#6
class Rouge::Lexers::CSharp < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/cuda.rb#7
class Rouge::Lexers::CUDA < ::Rouge::Lexers::Cpp
  class << self
    # source://rouge//lib/rouge/lexers/cuda.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/cuda.rb#21
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/ceylon.rb#6
class Rouge::Lexers::Ceylon < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/cfscript.rb#7
class Rouge::Lexers::Cfscript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/cfscript.rb#20
    def declarations; end

    # source://rouge//lib/rouge/lexers/cfscript.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/cfscript.rb#26
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/clean.rb#6
class Rouge::Lexers::Clean < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/clean.rb#13
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/clojure.rb#6
class Rouge::Lexers::Clojure < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/clojure.rb#70
  def name_token(name); end

  class << self
    # source://rouge//lib/rouge/lexers/clojure.rb#24
    def builtins; end

    # source://rouge//lib/rouge/lexers/clojure.rb#17
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/coffeescript.rb#6
class Rouge::Lexers::Coffeescript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/coffeescript.rb#41
    def builtins; end

    # source://rouge//lib/rouge/lexers/coffeescript.rb#35
    def constants; end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/coffeescript.rb#15
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/coffeescript.rb#19
    def keywords; end

    # source://rouge//lib/rouge/lexers/coffeescript.rb#28
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/common_lisp.rb#6
class Rouge::Lexers::CommonLisp < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/common_lisp.rb#201
Rouge::Lexers::CommonLisp::BUILTIN_CLASSES = T.let(T.unsafe(nil), Set)

# 638 functions
#
# source://rouge//lib/rouge/lexers/common_lisp.rb#16
Rouge::Lexers::CommonLisp::BUILTIN_FUNCTIONS = T.let(T.unsafe(nil), Set)

# source://rouge//lib/rouge/lexers/common_lisp.rb#183
Rouge::Lexers::CommonLisp::BUILTIN_TYPES = T.let(T.unsafe(nil), Set)

# source://rouge//lib/rouge/lexers/common_lisp.rb#178
Rouge::Lexers::CommonLisp::DECLARATIONS = T.let(T.unsafe(nil), Set)

# source://rouge//lib/rouge/lexers/common_lisp.rb#173
Rouge::Lexers::CommonLisp::LAMBDA_LIST_KEYWORDS = T.let(T.unsafe(nil), Set)

# source://rouge//lib/rouge/lexers/common_lisp.rb#152
Rouge::Lexers::CommonLisp::MACROS = T.let(T.unsafe(nil), Set)

# source://rouge//lib/rouge/lexers/common_lisp.rb#145
Rouge::Lexers::CommonLisp::SPECIAL_FORMS = T.let(T.unsafe(nil), Set)

# source://rouge//lib/rouge/lexers/conf.rb#6
class Rouge::Lexers::Conf < ::Rouge::RegexLexer; end

# The {ConsoleLexer} class is intended to lex content that represents the
# text that would display in a console/terminal. As distinct from the
# {Shell} lexer, {ConsoleLexer} will try to parse out the prompt from each
# line before passing the remainder of the line to the language lexer for
# the shell (by default, the {Shell} lexer).
#
# The {ConsoleLexer} class accepts five options:
# 1. **lang**: the shell language to lex (default: `shell`);
# 2. **output**: the output language (default: `plaintext?token=Generic.Output`);
# 3. **prompt**: comma-separated list of strings that indicate the end of a
#    prompt (default: `$,#,>,;`);
# 4. **comments**: whether to enable comments.
# 5. **error**: comma-separated list of strings that indicate the start of an
#    error message
#
# The comments option, if enabled, will lex lines that begin with a `#` as a
# comment. Please note that this option will only work if the prompt is
# either not manually specified or, if manually specified, does not include
# the `#` character.
#
# Most Markdown lexers that recognise GitHub-Flavored Markdown syntax, will
# pass the language string to Rouge as written in the original document.
# This allows an end user to pass options to {ConsoleLexer} by passing them
# as CGI-style parameters as in the example below.
#
# <pre>Here's some regular text.
#
# ```console?comments=true
# # This is a comment
# $ cp foo bar
# ```
#
# Some more regular text.</pre>
#
# source://rouge//lib/rouge/lexers/console.rb#40
class Rouge::Lexers::ConsoleLexer < ::Rouge::Lexer
  # @return [ConsoleLexer] a new instance of ConsoleLexer
  #
  # source://rouge//lib/rouge/lexers/console.rb#52
  def initialize(*_arg0); end

  # whether to allow comments. if manually specifying a prompt that isn't
  # simply "#", we flag this to on
  #
  # @return [Boolean]
  #
  # source://rouge//lib/rouge/lexers/console.rb#63
  def allow_comments?; end

  # source://rouge//lib/rouge/lexers/console.rb#72
  def comment_regex; end

  # source://rouge//lib/rouge/lexers/console.rb#76
  def end_chars; end

  # source://rouge//lib/rouge/lexers/console.rb#86
  def error_regex; end

  # source://rouge//lib/rouge/lexers/console.rb#92
  def lang_lexer; end

  # source://rouge//lib/rouge/lexers/console.rb#105
  def line_regex; end

  # source://rouge//lib/rouge/lexers/console.rb#109
  def output_lexer; end

  # source://rouge//lib/rouge/lexers/console.rb#122
  def process_line(input, &output); end

  # source://rouge//lib/rouge/lexers/console.rb#167
  def prompt_prefix_regex; end

  # source://rouge//lib/rouge/lexers/console.rb#175
  def prompt_regex; end

  # source://rouge//lib/rouge/lexers/console.rb#181
  def stream_tokens(input, &output); end
end

# source://rouge//lib/rouge/lexers/coq.rb#6
class Rouge::Lexers::Coq < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/coq.rb#69
    def classify(x); end

    # source://rouge//lib/rouge/lexers/coq.rb#19
    def coq; end

    # source://rouge//lib/rouge/lexers/coq.rb#65
    def end_sentence; end

    # source://rouge//lib/rouge/lexers/coq.rb#12
    def gallina; end

    # source://rouge//lib/rouge/lexers/coq.rb#59
    def keyopts; end

    # source://rouge//lib/rouge/lexers/coq.rb#32
    def ltac; end

    # source://rouge//lib/rouge/lexers/coq.rb#46
    def tacticals; end

    # source://rouge//lib/rouge/lexers/coq.rb#52
    def terminators; end
  end
end

# source://rouge//lib/rouge/lexers/cpp.rb#8
class Rouge::Lexers::Cpp < ::Rouge::Lexers::C
  class << self
    # source://rouge//lib/rouge/lexers/cpp.rb#23
    def keywords; end

    # source://rouge//lib/rouge/lexers/cpp.rb#37
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/cpp.rb#43
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/crystal.rb#6
class Rouge::Lexers::Crystal < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/crystal.rb#15
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/cypher.rb#6
class Rouge::Lexers::Cypher < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/cypher.rb#15
    def functions; end

    # source://rouge//lib/rouge/lexers/cypher.rb#34
    def keywords; end

    # source://rouge//lib/rouge/lexers/cypher.rb#28
    def predicates; end
  end
end

# source://rouge//lib/rouge/lexers/cython.rb#8
class Rouge::Lexers::Cython < ::Rouge::Lexers::Python
  # @return [Cython] a new instance of Cython
  #
  # source://rouge//lib/rouge/lexers/cython.rb#16
  def initialize(opts = T.unsafe(nil)); end

  class << self
    # source://rouge//lib/rouge/lexers/cython.rb#27
    def c_keywords; end

    # source://rouge//lib/rouge/lexers/cython.rb#21
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/d.rb#6
class Rouge::Lexers::D < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/dafny.rb#6
class Rouge::Lexers::Dafny < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/dart.rb#6
class Rouge::Lexers::Dart < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/datastudio.rb#6
class Rouge::Lexers::Datastudio < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/datastudio.rb#16
    def sql_keywords; end
  end
end

# source://rouge//lib/rouge/lexers/diff.rb#5
class Rouge::Lexers::Diff < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/diff.rb#14
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/digdag.rb#8
class Rouge::Lexers::Digdag < ::Rouge::Lexers::YAML; end

# http://docs.digdag.io/operators.html
# as of digdag v0.9.10
#
# source://rouge//lib/rouge/lexers/digdag.rb#18
Rouge::Lexers::Digdag::KEYWORD_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/docker.rb#6
class Rouge::Lexers::Docker < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/docker.rb#14
Rouge::Lexers::Docker::KEYWORDS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/dot.rb#6
class Rouge::Lexers::Dot < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/ecl.rb#6
class Rouge::Lexers::ECL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/ecl.rb#16
    def class_first; end

    # source://rouge//lib/rouge/lexers/ecl.rb#22
    def class_second; end

    # source://rouge//lib/rouge/lexers/ecl.rb#28
    def functions; end

    # source://rouge//lib/rouge/lexers/ecl.rb#51
    def keywords; end

    # source://rouge//lib/rouge/lexers/ecl.rb#71
    def template; end

    # source://rouge//lib/rouge/lexers/ecl.rb#81
    def type; end

    # source://rouge//lib/rouge/lexers/ecl.rb#89
    def typed; end
  end
end

# source://rouge//lib/rouge/lexers/eex.rb#5
class Rouge::Lexers::EEX < ::Rouge::TemplateLexer
  # @return [EEX] a new instance of EEX
  #
  # source://rouge//lib/rouge/lexers/eex.rb#14
  def initialize(opts = T.unsafe(nil)); end
end

# source://rouge//lib/rouge/lexers/epp.rb#5
class Rouge::Lexers::EPP < ::Rouge::TemplateLexer
  # @return [EPP] a new instance of EPP
  #
  # source://rouge//lib/rouge/lexers/epp.rb#13
  def initialize(opts = T.unsafe(nil)); end
end

# source://rouge//lib/rouge/lexers/erb.rb#6
class Rouge::Lexers::ERB < ::Rouge::TemplateLexer
  # @return [ERB] a new instance of ERB
  #
  # source://rouge//lib/rouge/lexers/erb.rb#15
  def initialize(opts = T.unsafe(nil)); end
end

# source://rouge//lib/rouge/lexers/eiffel.rb#6
class Rouge::Lexers::Eiffel < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/eiffel.rb#23
Rouge::Lexers::Eiffel::BooleanConstants = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/eiffel.rb#14
Rouge::Lexers::Eiffel::LanguageKeywords = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/eiffel.rb#25
Rouge::Lexers::Eiffel::LanguageVariables = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/eiffel.rb#27
Rouge::Lexers::Eiffel::SimpleString = T.let(T.unsafe(nil), Regexp)

# Direct port of pygments Lexer.
# See: https://bitbucket.org/birkenfeld/pygments-main/src/7304e4759ae65343d89a51359ca538912519cc31/pygments/lexers/functional.py?at=default#cl-2362
#
# source://rouge//lib/rouge/lexers/elixir.rb#8
class Rouge::Lexers::Elixir < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/elm.rb#6
class Rouge::Lexers::Elm < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/email.rb#6
class Rouge::Lexers::Email < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/erlang.rb#6
class Rouge::Lexers::Erlang < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/escape.rb#6
class Rouge::Lexers::Escape < ::Rouge::Lexer
  # @return [Escape] a new instance of Escape
  #
  # source://rouge//lib/rouge/lexers/escape.rb#20
  def initialize(*_arg0); end

  # Returns the value of attribute end.
  #
  # source://rouge//lib/rouge/lexers/escape.rb#17
  def end; end

  # Returns the value of attribute lang.
  #
  # source://rouge//lib/rouge/lexers/escape.rb#18
  def lang; end

  # Returns the value of attribute start.
  #
  # source://rouge//lib/rouge/lexers/escape.rb#16
  def start; end

  # source://rouge//lib/rouge/lexers/escape.rb#35
  def stream_tokens(str, &b); end

  # source://rouge//lib/rouge/lexers/escape.rb#31
  def to_end_regex; end

  # source://rouge//lib/rouge/lexers/escape.rb#27
  def to_start_regex; end
end

# source://rouge//lib/rouge/lexers/fsharp.rb#6
class Rouge::Lexers::FSharp < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/fsharp.rb#29
    def keyopts; end

    # source://rouge//lib/rouge/lexers/fsharp.rb#13
    def keywords; end

    # source://rouge//lib/rouge/lexers/fsharp.rb#40
    def primitives; end

    # source://rouge//lib/rouge/lexers/fsharp.rb#36
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/factor.rb#6
class Rouge::Lexers::Factor < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/factor.rb#17
    def builtins; end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/factor.rb#13
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/fluent.rb#6
class Rouge::Lexers::Fluent < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/fortran.rb#10
class Rouge::Lexers::Fortran < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/fortran.rb#53
    def intrinsics; end

    # source://rouge//lib/rouge/lexers/fortran.rb#23
    def keywords; end

    # source://rouge//lib/rouge/lexers/fortran.rb#45
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/freefem.rb#8
class Rouge::Lexers::FreeFEM < ::Rouge::Lexers::Cpp
  class << self
    # source://rouge//lib/rouge/lexers/freefem.rb#170
    def attributes; end

    # source://rouge//lib/rouge/lexers/freefem.rb#56
    def builtins; end

    # Override C/C++ ones (for example, `do` does not exists)
    #
    # source://rouge//lib/rouge/lexers/freefem.rb#18
    def keywords; end

    # Override C/C++ ones (for example, `double` does not exists)
    #
    # source://rouge//lib/rouge/lexers/freefem.rb#25
    def keywords_type; end

    # Override C/C++ ones (totally different)
    #
    # source://rouge//lib/rouge/lexers/freefem.rb#34
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/gdscript.rb#6
class Rouge::Lexers::GDScript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/gdscript.rb#30
    def builtins; end

    # source://rouge//lib/rouge/lexers/gdscript.rb#43
    def builtins_type; end

    # source://rouge//lib/rouge/lexers/gdscript.rb#14
    def keywords; end

    # Reserved for future implementation
    #
    # source://rouge//lib/rouge/lexers/gdscript.rb#24
    def keywords_reserved; end
  end
end

# source://rouge//lib/rouge/lexers/ghc_cmm.rb#15
class Rouge::Lexers::GHCCmm < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/ghc_core.rb#8
class Rouge::Lexers::GHCCore < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/gherkin.rb#6
class Rouge::Lexers::Gherkin < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/gherkin.rb#16
    def detect?(text); end

    # self-modifying method that loads the keywords file
    #
    # source://rouge//lib/rouge/lexers/gherkin.rb#21
    def keywords; end

    # source://rouge//lib/rouge/lexers/gherkin.rb#26
    def step_regex; end
  end
end

# This file defines the GLSL language lexer to the Rouge
# syntax highlighter.
#
# Author: Sri Harsha Chilakapati
#
# source://rouge//lib/rouge/lexers/glsl.rb#12
class Rouge::Lexers::Glsl < ::Rouge::Lexers::C
  class << self
    # source://rouge//lib/rouge/lexers/glsl.rb#87
    def builtins; end

    # source://rouge//lib/rouge/lexers/glsl.rb#20
    def keywords; end

    # source://rouge//lib/rouge/lexers/glsl.rb#35
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/glsl.rb#61
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/go.rb#6
class Rouge::Lexers::Go < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/go.rb#96
Rouge::Lexers::Go::BIG_U_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#102
Rouge::Lexers::Go::BYTE_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#103
Rouge::Lexers::Go::CHAR_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#35
Rouge::Lexers::Go::COMMENT = T.let(T.unsafe(nil), Regexp)

# Floating-point literals
#
# source://rouge//lib/rouge/lexers/go.rb#81
Rouge::Lexers::Go::DECIMALS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#27
Rouge::Lexers::Go::DECIMAL_DIGIT = T.let(T.unsafe(nil), Regexp)

# Integer literals
#
# source://rouge//lib/rouge/lexers/go.rb#74
Rouge::Lexers::Go::DECIMAL_LIT = T.let(T.unsafe(nil), Regexp)

# Rune literals
#
# source://rouge//lib/rouge/lexers/go.rb#94
Rouge::Lexers::Go::ESCAPED_CHAR = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#104
Rouge::Lexers::Go::ESCAPE_SEQUENCE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#82
Rouge::Lexers::Go::EXPONENT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#83
Rouge::Lexers::Go::FLOAT_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#34
Rouge::Lexers::Go::GENERAL_COMMENT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#101
Rouge::Lexers::Go::HEX_BYTE_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#29
Rouge::Lexers::Go::HEX_DIGIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#76
Rouge::Lexers::Go::HEX_LIT = T.let(T.unsafe(nil), Regexp)

# Identifiers
#
# source://rouge//lib/rouge/lexers/go.rb#53
Rouge::Lexers::Go::IDENTIFIER = T.let(T.unsafe(nil), Regexp)

# Imaginary literals
#
# source://rouge//lib/rouge/lexers/go.rb#90
Rouge::Lexers::Go::IMAGINARY_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#113
Rouge::Lexers::Go::INTERPRETED_STRING_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#77
Rouge::Lexers::Go::INT_LIT = T.let(T.unsafe(nil), Regexp)

# Keywords
#
# source://rouge//lib/rouge/lexers/go.rb#39
Rouge::Lexers::Go::KEYWORD = T.let(T.unsafe(nil), Regexp)

# Letters and digits
#
# source://rouge//lib/rouge/lexers/go.rb#26
Rouge::Lexers::Go::LETTER = T.let(T.unsafe(nil), Regexp)

# Comments
#
# source://rouge//lib/rouge/lexers/go.rb#33
Rouge::Lexers::Go::LINE_COMMENT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#95
Rouge::Lexers::Go::LITTLE_U_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#19
Rouge::Lexers::Go::NEWLINE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#100
Rouge::Lexers::Go::OCTAL_BYTE_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#28
Rouge::Lexers::Go::OCTAL_DIGIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#75
Rouge::Lexers::Go::OCTAL_LIT = T.let(T.unsafe(nil), Regexp)

# Operators and delimiters
#
# source://rouge//lib/rouge/lexers/go.rb#58
Rouge::Lexers::Go::OPERATOR = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#130
Rouge::Lexers::Go::PREDECLARED_CONSTANTS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#132
Rouge::Lexers::Go::PREDECLARED_FUNCTIONS = T.let(T.unsafe(nil), Regexp)

# Predeclared identifiers
#
# source://rouge//lib/rouge/lexers/go.rb#120
Rouge::Lexers::Go::PREDECLARED_TYPES = T.let(T.unsafe(nil), Regexp)

# String literals
#
# source://rouge//lib/rouge/lexers/go.rb#112
Rouge::Lexers::Go::RAW_STRING_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#68
Rouge::Lexers::Go::SEPARATOR = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#116
Rouge::Lexers::Go::STRING_LIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#20
Rouge::Lexers::Go::UNICODE_CHAR = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#22
Rouge::Lexers::Go::UNICODE_DIGIT = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#21
Rouge::Lexers::Go::UNICODE_LETTER = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/go.rb#97
Rouge::Lexers::Go::UNICODE_VALUE = T.let(T.unsafe(nil), Regexp)

# Characters
#
# source://rouge//lib/rouge/lexers/go.rb#17
Rouge::Lexers::Go::WHITE_SPACE = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/gradle.rb#8
class Rouge::Lexers::Gradle < ::Rouge::Lexers::Groovy
  class << self
    # source://rouge//lib/rouge/lexers/gradle.rb#16
    def keywords; end

    # source://rouge//lib/rouge/lexers/gradle.rb#23
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/graphql.rb#6
class Rouge::Lexers::GraphQL < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/groovy.rb#6
class Rouge::Lexers::Groovy < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/groovy.rb#38
    def constants; end

    # source://rouge//lib/rouge/lexers/groovy.rb#24
    def declarations; end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/groovy.rb#13
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/groovy.rb#17
    def keywords; end

    # source://rouge//lib/rouge/lexers/groovy.rb#32
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/hlsl.rb#8
class Rouge::Lexers::HLSL < ::Rouge::Lexers::C
  class << self
    # source://rouge//lib/rouge/lexers/hlsl.rb#74
    def builtins; end

    # source://rouge//lib/rouge/lexers/hlsl.rb#15
    def keywords; end

    # source://rouge//lib/rouge/lexers/hlsl.rb#28
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/hlsl.rb#65
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/hocon.rb#8
class Rouge::Lexers::HOCON < ::Rouge::Lexers::JSON; end

# source://rouge//lib/rouge/lexers/hql.rb#7
class Rouge::Lexers::HQL < ::Rouge::Lexers::SQL
  class << self
    # source://rouge//lib/rouge/lexers/hql.rb#13
    def keywords; end

    # source://rouge//lib/rouge/lexers/hql.rb#101
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/html.rb#6
class Rouge::Lexers::HTML < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/html.rb#13
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/http.rb#6
class Rouge::Lexers::HTTP < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/http.rb#17
  def content_lexer; end

  # source://rouge//lib/rouge/lexers/http.rb#21
  def guess_content_lexer; end

  class << self
    # source://rouge//lib/rouge/lexers/http.rb#13
    def http_methods; end
  end
end

# source://rouge//lib/rouge/lexers/hack.rb#8
class Rouge::Lexers::Hack < ::Rouge::Lexers::PHP
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/hack.rb#15
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/hack.rb#24
    def keywords; end
  end
end

# A lexer for the Haml templating system for Ruby.
#
# @see http://haml.info
#
# source://rouge//lib/rouge/lexers/haml.rb#8
class Rouge::Lexers::Haml < ::Rouge::RegexLexer
  include ::Rouge::Indentation

  # @option opts
  # @param opts [Hash] a customizable set of options
  # @return [Haml] a new instance of Haml
  #
  # source://rouge//lib/rouge/lexers/haml.rb#26
  def initialize(opts = T.unsafe(nil)); end

  # Returns the value of attribute filters.
  #
  # source://rouge//lib/rouge/lexers/haml.rb#21
  def filters; end

  # source://rouge//lib/rouge/lexers/haml.rb#50
  def html; end

  # source://rouge//lib/rouge/lexers/haml.rb#46
  def ruby; end

  # source://rouge//lib/rouge/lexers/haml.rb#54
  def ruby!(state); end
end

# source://rouge//lib/rouge/lexers/handlebars.rb#6
class Rouge::Lexers::Handlebars < ::Rouge::TemplateLexer; end

# source://rouge//lib/rouge/lexers/haskell.rb#6
class Rouge::Lexers::Haskell < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/haskell.rb#15
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/haxe.rb#5
class Rouge::Lexers::Haxe < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/haxe.rb#49
    def builtins; end

    # source://rouge//lib/rouge/lexers/haxe.rb#45
    def constants; end

    # source://rouge//lib/rouge/lexers/haxe.rb#32
    def declarations; end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/haxe.rb#14
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/haxe.rb#26
    def imports; end

    # source://rouge//lib/rouge/lexers/haxe.rb#18
    def keywords; end

    # source://rouge//lib/rouge/lexers/haxe.rb#39
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/hcl.rb#6
class Rouge::Lexers::Hcl < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/hcl.rb#55
    def builtins; end

    # source://rouge//lib/rouge/lexers/hcl.rb#51
    def constants; end

    # source://rouge//lib/rouge/lexers/hcl.rb#43
    def declarations; end

    # source://rouge//lib/rouge/lexers/hcl.rb#39
    def keywords; end

    # source://rouge//lib/rouge/lexers/hcl.rb#47
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/hylang.rb#6
class Rouge::Lexers::HyLang < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/hylang.rb#50
  def name_token(name); end

  class << self
    # source://rouge//lib/rouge/lexers/hylang.rb#25
    def builtins; end

    # source://rouge//lib/rouge/lexers/hylang.rb#17
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/idlang.rb#8
class Rouge::Lexers::IDLang < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/idlang.rb#52
    def conditionals; end

    # source://rouge//lib/rouge/lexers/idlang.rb#39
    def decorators; end

    # source://rouge//lib/rouge/lexers/idlang.rb#19
    def exec_unit; end

    # source://rouge//lib/rouge/lexers/idlang.rb#25
    def keywords; end

    # source://rouge//lib/rouge/lexers/idlang.rb#46
    def operators; end

    # source://rouge//lib/rouge/lexers/idlang.rb#60
    def routines; end

    # source://rouge//lib/rouge/lexers/idlang.rb#32
    def standalone_statements; end
  end
end

# source://rouge//lib/rouge/lexers/ini.rb#6
class Rouge::Lexers::INI < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/io.rb#6
class Rouge::Lexers::IO < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/io.rb#21
    def builtins; end

    # source://rouge//lib/rouge/lexers/io.rb#17
    def constants; end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/io.rb#13
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/irb.rb#8
class Rouge::Lexers::IRBLexer < ::Rouge::Lexers::ConsoleLexer
  # @return [Boolean]
  #
  # source://rouge//lib/rouge/lexers/irb.rb#29
  def allow_comments?; end

  # source://rouge//lib/rouge/lexers/irb.rb#21
  def lang_lexer; end

  # source://rouge//lib/rouge/lexers/irb.rb#17
  def output_lexer; end

  # source://rouge//lib/rouge/lexers/irb.rb#25
  def prompt_regex; end
end

# source://rouge//lib/rouge/lexers/irb.rb#35
class Rouge::Lexers::IRBOutputLexer < ::Rouge::Lexers::Ruby; end

# source://rouge//lib/rouge/lexers/isbl.rb#6
class Rouge::Lexers::ISBL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/isbl.rb#12
    def builtins; end

    # source://rouge//lib/rouge/lexers/isbl.rb#17
    def constants; end

    # source://rouge//lib/rouge/lexers/isbl.rb#25
    def globals; end

    # source://rouge//lib/rouge/lexers/isbl.rb#21
    def interfaces; end

    # source://rouge//lib/rouge/lexers/isbl.rb#29
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/idris.rb#6
class Rouge::Lexers::Idris < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/idris.rb#23
    def ascii; end

    # source://rouge//lib/rouge/lexers/idris.rb#30
    def prelude_functions; end

    # source://rouge//lib/rouge/lexers/idris.rb#15
    def reserved_keywords; end
  end
end

# source://rouge//lib/rouge/lexers/igorpro.rb#6
class Rouge::Lexers::IgorPro < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/igorpro.rb#44
    def igorConstants; end

    # source://rouge//lib/rouge/lexers/igorpro.rb#36
    def igorDeclarations; end

    # source://rouge//lib/rouge/lexers/igorpro.rb#50
    def igorFunction; end

    # source://rouge//lib/rouge/lexers/igorpro.rb#322
    def igorOperation; end

    # source://rouge//lib/rouge/lexers/igorpro.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/igorpro.rb#509
    def object_name; end

    # source://rouge//lib/rouge/lexers/igorpro.rb#28
    def preprocessor; end
  end
end

# source://rouge//lib/rouge/lexers/isabelle.rb#7
class Rouge::Lexers::Isabelle < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/isabelle.rb#127
    def keyword_abandon_proof; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#29
    def keyword_diag; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#15
    def keyword_minor; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#150
    def keyword_proof_asm; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#154
    def keyword_proof_asm_goal; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#135
    def keyword_proof_block; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#139
    def keyword_proof_chain; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#143
    def keyword_proof_decl; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#131
    def keyword_proof_goal; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#158
    def keyword_proof_script; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#123
    def keyword_qed; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#57
    def keyword_section; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#61
    def keyword_subsection; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#65
    def keyword_theory_decl; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#109
    def keyword_theory_goal; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#105
    def keyword_theory_script; end

    # source://rouge//lib/rouge/lexers/isabelle.rb#53
    def keyword_thy; end
  end
end

# source://rouge//lib/rouge/lexers/j.rb#6
class Rouge::Lexers::J < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/j.rb#77
    def control_words; end

    # source://rouge//lib/rouge/lexers/j.rb#84
    def control_words_id; end

    # https://code.jsoftware.com/wiki/NuVoc
    #
    # source://rouge//lib/rouge/lexers/j.rb#30
    def inflection_list; end

    # source://rouge//lib/rouge/lexers/j.rb#72
    def primitive(char, inflection); end

    # source://rouge//lib/rouge/lexers/j.rb#34
    def primitive_table; end

    # https://code.jsoftware.com/wiki/Vocabulary/PartsOfSpeech
    #
    # source://rouge//lib/rouge/lexers/j.rb#17
    def token_map; end
  end
end

# source://rouge//lib/rouge/lexers/jsl.rb#6
class Rouge::Lexers::JSL < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/json.rb#6
class Rouge::Lexers::JSON < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/json_doc.rb#8
class Rouge::Lexers::JSONDOC < ::Rouge::Lexers::JSON; end

# source://rouge//lib/rouge/lexers/jsp.rb#6
class Rouge::Lexers::JSP < ::Rouge::TemplateLexer
  # @return [JSP] a new instance of JSP
  #
  # source://rouge//lib/rouge/lexers/jsp.rb#12
  def initialize(*_arg0); end
end

# source://rouge//lib/rouge/lexers/jsx.rb#7
class Rouge::Lexers::JSX < ::Rouge::Lexers::Javascript; end

# source://rouge//lib/rouge/lexers/janet.rb#6
class Rouge::Lexers::Janet < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/janet.rb#107
  def name_token(name); end

  class << self
    # source://rouge//lib/rouge/lexers/janet.rb#23
    def bundled; end

    # source://rouge//lib/rouge/lexers/janet.rb#17
    def specials; end
  end
end

# source://rouge//lib/rouge/lexers/java.rb#6
class Rouge::Lexers::Java < ::Rouge::RegexLexer; end

# IMPORTANT NOTICE:
#
# Please do not copy this lexer and open a pull request
# for a new language. It will not get merged, you will
# be unhappy, and kittens will cry.
#
# source://rouge//lib/rouge/lexers/javascript.rb#12
class Rouge::Lexers::Javascript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/javascript.rb#127
    def builtins; end

    # source://rouge//lib/rouge/lexers/javascript.rb#123
    def constants; end

    # source://rouge//lib/rouge/lexers/javascript.rb#109
    def declarations; end

    # Pseudo-documentation: https://stackoverflow.com/questions/1661197/what-characters-are-valid-for-javascript-variable-names
    #
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/javascript.rb#24
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/javascript.rb#142
    def id_regex; end

    # source://rouge//lib/rouge/lexers/javascript.rb#101
    def keywords; end

    # source://rouge//lib/rouge/lexers/javascript.rb#116
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/jinja.rb#6
class Rouge::Lexers::Jinja < ::Rouge::TemplateLexer
  class << self
    # source://rouge//lib/rouge/lexers/jinja.rb#16
    def keywords; end

    # source://rouge//lib/rouge/lexers/jinja.rb#30
    def pseudo_keywords; end

    # source://rouge//lib/rouge/lexers/jinja.rb#24
    def tests; end

    # source://rouge//lib/rouge/lexers/jinja.rb#34
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/jsonnet.rb#6
class Rouge::Lexers::Jsonnet < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/jsonnet.rb#32
    def builtins; end

    # source://rouge//lib/rouge/lexers/jsonnet.rb#26
    def constants; end

    # source://rouge//lib/rouge/lexers/jsonnet.rb#20
    def declarations; end

    # source://rouge//lib/rouge/lexers/jsonnet.rb#13
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/julia.rb#6
class Rouge::Lexers::Julia < ::Rouge::RegexLexer
  class << self
    # Documentation: https://docs.julialang.org/en/v1/manual/variables/#Allowed-Variable-Names-1
    #
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/julia.rb#16
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/julia.rb#20
Rouge::Lexers::Julia::BUILTINS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/julia.rb#30
Rouge::Lexers::Julia::KEYWORDS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/julia.rb#170
Rouge::Lexers::Julia::OPERATORS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/julia.rb#184
Rouge::Lexers::Julia::PUNCTUATION = T.let(T.unsafe(nil), Regexp)

# NOTE: The list of types was generated automatically using the following script:
# using Pkg, InteractiveUtils
#
# allnames = [names(Core); names(Base, imported=true)]
#
# for stdlib in readdir(Pkg.Types.stdlib_dir())
#     mod = Symbol(basename(stdlib))
#     @eval begin
#         using $mod
#         append!(allnames, names($mod))
#     end
# end
#
# sort!(unique!(allnames))
#
# i = 1
# for sym in allnames
#     global i # needed at the top level, e.g. in the REPL
#     isdefined(Main, sym) || continue
#     getfield(which(Main, sym), sym) isa Type || continue
#     sym === :(=>) && continue # Actually an alias for Pair
#     print("| ", sym)
#     i % 3 == 0 ? println() : print(" ") # print 3 to a line
#     i += 1
# end
#
# source://rouge//lib/rouge/lexers/julia.rb#65
Rouge::Lexers::Julia::TYPES = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/kotlin.rb#6
class Rouge::Lexers::Kotlin < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/llvm.rb#6
class Rouge::Lexers::LLVM < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/llvm.rb#22
    def instructions; end

    # source://rouge//lib/rouge/lexers/llvm.rb#17
    def keywords; end

    # source://rouge//lib/rouge/lexers/llvm.rb#27
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/lasso.rb#8
class Rouge::Lexers::Lasso < ::Rouge::TemplateLexer
  # @return [Lasso] a new instance of Lasso
  #
  # source://rouge//lib/rouge/lexers/lasso.rb#23
  def initialize(*_arg0); end

  # @return [Boolean]
  #
  # source://rouge//lib/rouge/lexers/lasso.rb#29
  def start_inline?; end

  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/lasso.rb#18
    def detect?(text); end

    # self-modifying method that loads the keywords file
    #
    # source://rouge//lib/rouge/lexers/lasso.rb#38
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/lean.rb#7
class Rouge::Lexers::Lean < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/lean.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/lean.rb#103
    def operators; end

    # source://rouge//lib/rouge/lexers/lean.rb#95
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/liquid.rb#6
class Rouge::Lexers::Liquid < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/literate_coffeescript.rb#6
class Rouge::Lexers::LiterateCoffeescript < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/literate_coffeescript.rb#17
  def coffee; end

  # source://rouge//lib/rouge/lexers/literate_coffeescript.rb#13
  def markdown; end
end

# source://rouge//lib/rouge/lexers/literate_haskell.rb#6
class Rouge::Lexers::LiterateHaskell < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/literate_haskell.rb#14
  def haskell; end
end

# source://rouge//lib/rouge/lexers/livescript.rb#6
class Rouge::Lexers::Livescript < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/livescript.rb#36
    def builtins; end

    # source://rouge//lib/rouge/lexers/livescript.rb#32
    def constants; end

    # source://rouge//lib/rouge/lexers/livescript.rb#19
    def declarations; end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/livescript.rb#15
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/livescript.rb#23
    def keywords; end

    # source://rouge//lib/rouge/lexers/livescript.rb#40
    def loop_control_keywords; end
  end
end

# source://rouge//lib/rouge/lexers/lua.rb#6
class Rouge::Lexers::Lua < ::Rouge::RegexLexer
  # @return [Lua] a new instance of Lua
  #
  # source://rouge//lib/rouge/lexers/lua.rb#17
  def initialize(opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/lexers/lua.rb#32
  def builtins; end

  class << self
    # source://rouge//lib/rouge/lexers/lua.rb#27
    def builtins; end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/lua.rb#23
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/lustre.rb#6
class Rouge::Lexers::Lustre < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/lustre.rb#13
    def keywords; end

    # source://rouge//lib/rouge/lexers/lustre.rb#27
    def primitives; end

    # source://rouge//lib/rouge/lexers/lustre.rb#21
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/lutin.rb#9
class Rouge::Lexers::Lutin < ::Rouge::Lexers::Lustre
  class << self
    # source://rouge//lib/rouge/lexers/lutin.rb#16
    def keywords; end

    # source://rouge//lib/rouge/lexers/lutin.rb#28
    def primitives; end

    # source://rouge//lib/rouge/lexers/lutin.rb#23
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/m68k.rb#6
class Rouge::Lexers::M68k < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/m68k.rb#69
    def builtins; end

    # source://rouge//lib/rouge/lexers/m68k.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/m68k.rb#47
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/m68k.rb#53
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/mxml.rb#6
class Rouge::Lexers::MXML < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/magik.rb#6
class Rouge::Lexers::Magik < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/magik.rb#63
    def character; end

    # source://rouge//lib/rouge/lexers/magik.rb#56
    def decimal; end

    # source://rouge//lib/rouge/lexers/magik.rb#47
    def digits; end

    # source://rouge//lib/rouge/lexers/magik.rb#53
    def exponent; end

    # source://rouge//lib/rouge/lexers/magik.rb#82
    def global_ref; end

    # source://rouge//lib/rouge/lexers/magik.rb#73
    def identifier; end

    # source://rouge//lib/rouge/lexers/magik.rb#13
    def keywords; end

    # source://rouge//lib/rouge/lexers/magik.rb#85
    def label; end

    # source://rouge//lib/rouge/lexers/magik.rb#59
    def number; end

    # source://rouge//lib/rouge/lexers/magik.rb#76
    def package_identifier; end

    # source://rouge//lib/rouge/lexers/magik.rb#70
    def piped_identifier; end

    # source://rouge//lib/rouge/lexers/magik.rb#50
    def radix; end

    # source://rouge//lib/rouge/lexers/magik.rb#67
    def simple_identifier; end

    # source://rouge//lib/rouge/lexers/magik.rb#40
    def string_double; end

    # source://rouge//lib/rouge/lexers/magik.rb#43
    def string_single; end

    # source://rouge//lib/rouge/lexers/magik.rb#79
    def symbol; end
  end
end

# source://rouge//lib/rouge/lexers/make.rb#6
class Rouge::Lexers::Make < ::Rouge::RegexLexer
  # TODO: Add support for special keywords
  # bsd_special = %w(
  #   include undef error warning if else elif endif for endfor
  # )
  #
  # @return [Make] a new instance of Make
  #
  # source://rouge//lib/rouge/lexers/make.rb#28
  def initialize(opts = T.unsafe(nil)); end

  class << self
    # source://rouge//lib/rouge/lexers/make.rb#14
    def functions; end
  end
end

# source://rouge//lib/rouge/lexers/markdown.rb#6
class Rouge::Lexers::Markdown < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/markdown.rb#15
  def html; end
end

# source://rouge//lib/rouge/lexers/mason.rb#6
class Rouge::Lexers::Mason < ::Rouge::TemplateLexer
  # @return [Mason] a new instance of Mason
  #
  # source://rouge//lib/rouge/lexers/mason.rb#13
  def initialize(*_arg0); end
end

# source://rouge//lib/rouge/lexers/mason.rb#21
Rouge::Lexers::Mason::COMPONENTS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/mason.rb#20
Rouge::Lexers::Mason::PERL_BLOCKS = T.let(T.unsafe(nil), Array)

# Note: If you add a tag in the lines below, you also need to modify "disambiguate '*.m'" in file disambiguation.rb
#
# source://rouge//lib/rouge/lexers/mason.rb#19
Rouge::Lexers::Mason::TEXT_BLOCKS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/mathematica.rb#6
class Rouge::Lexers::Mathematica < ::Rouge::RegexLexer
  class << self
    # The list of built-in symbols comes from a wolfram server and is created automatically by rake
    #
    # source://rouge//lib/rouge/lexers/mathematica.rb#58
    def builtins; end

    # Although Module, With and Block are normal built-in symbols, we give them a special treatment as they are
    # the most important expressions for defining local variables
    #
    # source://rouge//lib/rouge/lexers/mathematica.rb#51
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/matlab.rb#6
class Rouge::Lexers::Matlab < ::Rouge::RegexLexer
  class << self
    # self-modifying method that loads the builtins file
    #
    # source://rouge//lib/rouge/lexers/matlab.rb#23
    def builtins; end

    # source://rouge//lib/rouge/lexers/matlab.rb#14
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/meson.rb#6
class Rouge::Lexers::Meson < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/meson.rb#43
  def current_string; end

  class << self
    # source://rouge//lib/rouge/lexers/meson.rb#26
    def builtin_functions; end

    # source://rouge//lib/rouge/lexers/meson.rb#20
    def builtin_variables; end

    # source://rouge//lib/rouge/lexers/meson.rb#13
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/meson.rb#138
class Rouge::Lexers::Meson::StringRegister < ::Array
  # @return [Boolean]
  #
  # source://rouge//lib/rouge/lexers/meson.rb#139
  def delim?(delim); end

  # source://rouge//lib/rouge/lexers/meson.rb#143
  def register(type: T.unsafe(nil), delim: T.unsafe(nil)); end

  # source://rouge//lib/rouge/lexers/meson.rb#147
  def remove; end

  # @return [Boolean]
  #
  # source://rouge//lib/rouge/lexers/meson.rb#151
  def type?(type); end
end

# source://rouge//lib/rouge/lexers/minizinc.rb#9
class Rouge::Lexers::MiniZinc < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/minizinc.rb#16
    def builtins; end

    # source://rouge//lib/rouge/lexers/minizinc.rb#28
    def keywords; end

    # source://rouge//lib/rouge/lexers/minizinc.rb#36
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/minizinc.rb#42
    def operators; end
  end
end

# source://rouge//lib/rouge/lexers/moonscript.rb#8
class Rouge::Lexers::Moonscript < ::Rouge::RegexLexer
  # @return [Moonscript] a new instance of Moonscript
  #
  # source://rouge//lib/rouge/lexers/moonscript.rb#19
  def initialize(*_arg0); end

  # source://rouge//lib/rouge/lexers/moonscript.rb#30
  def builtins; end

  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/moonscript.rb#26
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/mosel.rb#6
class Rouge::Lexers::Mosel < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/mosel.rb#16
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/msgtrans.rb#6
class Rouge::Lexers::MsgTrans < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/nasm.rb#8
class Rouge::Lexers::Nasm < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/nesasm.rb#6
class Rouge::Lexers::NesAsm < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/nesasm.rb#13
    def keywords; end

    # source://rouge//lib/rouge/lexers/nesasm.rb#28
    def keywords_reserved; end

    # source://rouge//lib/rouge/lexers/nesasm.rb#22
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/nginx.rb#6
class Rouge::Lexers::Nginx < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/nial.rb#6
class Rouge::Lexers::Nial < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/nial.rb#110
    def consts; end

    # source://rouge//lib/rouge/lexers/nial.rb#44
    def funcs; end

    # source://rouge//lib/rouge/lexers/nial.rb#12
    def keywords; end

    # source://rouge//lib/rouge/lexers/nial.rb#21
    def operators; end

    # source://rouge//lib/rouge/lexers/nial.rb#26
    def punctuations; end

    # source://rouge//lib/rouge/lexers/nial.rb#30
    def transformers; end
  end
end

# source://rouge//lib/rouge/lexers/nim.rb#6
class Rouge::Lexers::Nim < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/nim.rb#40
    def underscorize(words); end
  end
end

# source://rouge//lib/rouge/lexers/nim.rb#15
Rouge::Lexers::Nim::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/nim.rb#36
Rouge::Lexers::Nim::NAMESPACE = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/nim.rb#23
Rouge::Lexers::Nim::OPWORDS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/nim.rb#27
Rouge::Lexers::Nim::PSEUDOKEYWORDS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/nim.rb#31
Rouge::Lexers::Nim::TYPES = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/nix.rb#6
class Rouge::Lexers::Nix < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/ocl.rb#3
class Rouge::Lexers::OCL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/ocl.rb#25
    def builtins; end

    # source://rouge//lib/rouge/lexers/ocl.rb#37
    def functions; end

    # source://rouge//lib/rouge/lexers/ocl.rb#11
    def keywords; end

    # source://rouge//lib/rouge/lexers/ocl.rb#18
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/ocl.rb#31
    def operators; end
  end
end

# source://rouge//lib/rouge/lexers/ocaml.rb#8
class Rouge::Lexers::OCaml < ::Rouge::Lexers::OCamlCommon
  class << self
    # source://rouge//lib/rouge/lexers/ocaml.rb#15
    def keywords; end
  end
end

# shared states with Reasonml and ReScript
#
# source://rouge//lib/rouge/lexers/ocaml/common.rb#7
class Rouge::Lexers::OCamlCommon < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/ocaml/common.rb#8
    def keywords; end

    # source://rouge//lib/rouge/lexers/ocaml/common.rb#22
    def primitives; end

    # source://rouge//lib/rouge/lexers/ocaml/common.rb#18
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/objective_c.rb#9
class Rouge::Lexers::ObjectiveC < ::Rouge::Lexers::C
  extend ::Rouge::Lexers::ObjectiveCCommon
end

# source://rouge//lib/rouge/lexers/objective_c/common.rb#6
module Rouge::Lexers::ObjectiveCCommon
  # source://rouge//lib/rouge/lexers/objective_c/common.rb#17
  def at_builtins; end

  # source://rouge//lib/rouge/lexers/objective_c/common.rb#9
  def at_keywords; end

  # source://rouge//lib/rouge/lexers/objective_c/common.rb#21
  def builtins; end

  class << self
    # @private
    #
    # source://rouge//lib/rouge/lexers/objective_c/common.rb#25
    def extended(base); end
  end
end

# source://rouge//lib/rouge/lexers/objective_cpp.rb#9
class Rouge::Lexers::ObjectiveCpp < ::Rouge::Lexers::Cpp
  extend ::Rouge::Lexers::ObjectiveCCommon
end

# source://rouge//lib/rouge/lexers/openedge.rb#6
class Rouge::Lexers::OpenEdge < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/openedge.rb#18
    def keywords; end

    # source://rouge//lib/rouge/lexers/openedge.rb#351
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/opentype_feature_file.rb#6
class Rouge::Lexers::OpenTypeFeatureFile < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/opentype_feature_file.rb#13
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/php.rb#6
class Rouge::Lexers::PHP < ::Rouge::TemplateLexer
  # @return [PHP] a new instance of PHP
  #
  # source://rouge//lib/rouge/lexers/php.rb#21
  def initialize(*_arg0); end

  # source://rouge//lib/rouge/lexers/php.rb#56
  def builtins; end

  class << self
    # source://rouge//lib/rouge/lexers/php.rb#51
    def builtins; end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/php.rb#31
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/php.rb#37
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/plsql.rb#6
class Rouge::Lexers::PLSQL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/plsql.rb#33
    def keywords; end

    # source://rouge//lib/rouge/lexers/plsql.rb#392
    def keywords_func; end

    # source://rouge//lib/rouge/lexers/plsql.rb#13
    def keywords_reserved; end

    # source://rouge//lib/rouge/lexers/plsql.rb#434
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/pascal.rb#6
class Rouge::Lexers::Pascal < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/perl.rb#6
class Rouge::Lexers::Perl < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/perl.rb#16
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/plain_text.rb#6
class Rouge::Lexers::PlainText < ::Rouge::Lexer
  # @return [PlainText] a new instance of PlainText
  #
  # source://rouge//lib/rouge/lexers/plain_text.rb#16
  def initialize(*_arg0); end

  # @yield [self.token, string]
  #
  # source://rouge//lib/rouge/lexers/plain_text.rb#22
  def stream_tokens(string, &b); end

  # Returns the value of attribute token.
  #
  # source://rouge//lib/rouge/lexers/plain_text.rb#15
  def token; end
end

# source://rouge//lib/rouge/lexers/plist.rb#5
class Rouge::Lexers::Plist < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/pony.rb#6
class Rouge::Lexers::Pony < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/postscript.rb#7
class Rouge::Lexers::PostScript < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/postscript.rb#15
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/powershell.rb#7
class Rouge::Lexers::Powershell < ::Rouge::RegexLexer; end

# https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute?view=powershell-6
#
# source://rouge//lib/rouge/lexers/powershell.rb#16
Rouge::Lexers::Powershell::ATTRIBUTES = T.let(T.unsafe(nil), Array)

# https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables?view=powershell-6
#
# source://rouge//lib/rouge/lexers/powershell.rb#22
Rouge::Lexers::Powershell::AUTO_VARS = T.let(T.unsafe(nil), String)

# https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_reserved_words?view=powershell-6
#
# source://rouge//lib/rouge/lexers/powershell.rb#36
Rouge::Lexers::Powershell::KEYWORDS = T.let(T.unsafe(nil), String)

# https://devblogs.microsoft.com/scripting/powertip-find-a-list-of-powershell-type-accelerators/
# ([PSObject].Assembly.GetType("System.Management.Automation.TypeAccelerators")::Get).Keys -join ' '
#
# source://rouge//lib/rouge/lexers/powershell.rb#46
Rouge::Lexers::Powershell::KEYWORDS_TYPE = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/powershell.rb#74
Rouge::Lexers::Powershell::MULTILINE_KEYWORDS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/powershell.rb#65
Rouge::Lexers::Powershell::OPERATORS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/praat.rb#6
class Rouge::Lexers::Praat < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/praat.rb#14
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/prolog.rb#6
class Rouge::Lexers::Prolog < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/prometheus.rb#5
class Rouge::Lexers::Prometheus < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/prometheus.rb#13
    def functions; end
  end
end

# source://rouge//lib/rouge/lexers/properties.rb#6
class Rouge::Lexers::Properties < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/protobuf.rb#6
class Rouge::Lexers::Protobuf < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/puppet.rb#6
class Rouge::Lexers::Puppet < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/puppet.rb#25
    def constants; end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/puppet.rb#13
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/puppet.rb#18
    def keywords; end

    # source://rouge//lib/rouge/lexers/puppet.rb#31
    def metaparameters; end
  end
end

# source://rouge//lib/rouge/lexers/python.rb#6
class Rouge::Lexers::Python < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/python.rb#73
  def current_string; end

  class << self
    # source://rouge//lib/rouge/lexers/python.rb#28
    def builtins; end

    # source://rouge//lib/rouge/lexers/python.rb#42
    def builtins_pseudo; end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/python.rb#15
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/python.rb#46
    def exceptions; end

    # source://rouge//lib/rouge/lexers/python.rb#19
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/python.rb#230
class Rouge::Lexers::Python::StringRegister < ::Array
  # @return [Boolean]
  #
  # source://rouge//lib/rouge/lexers/python.rb#231
  def delim?(delim); end

  # source://rouge//lib/rouge/lexers/python.rb#235
  def register(type: T.unsafe(nil), delim: T.unsafe(nil)); end

  # source://rouge//lib/rouge/lexers/python.rb#239
  def remove; end

  # @return [Boolean]
  #
  # source://rouge//lib/rouge/lexers/python.rb#243
  def type?(type); end
end

# source://rouge//lib/rouge/lexers/q.rb#5
class Rouge::Lexers::Q < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/q.rb#27
    def builtins; end

    # source://rouge//lib/rouge/lexers/q.rb#15
    def keywords; end

    # source://rouge//lib/rouge/lexers/q.rb#19
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/qml.rb#8
class Rouge::Lexers::Qml < ::Rouge::Lexers::Javascript; end

# source://rouge//lib/rouge/lexers/r.rb#6
class Rouge::Lexers::R < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/r.rb#47
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/r.rb#23
Rouge::Lexers::R::BUILTIN_CONSTANTS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/r.rb#16
Rouge::Lexers::R::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/r.rb#18
Rouge::Lexers::R::KEYWORD_CONSTANTS = T.let(T.unsafe(nil), Array)

# These are all the functions in `base` that are implemented as a
# `.Primitive`, minus those functions that are also keywords.
#
# source://rouge//lib/rouge/lexers/r.rb#27
Rouge::Lexers::R::PRIMITIVE_FUNCTIONS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/racket.rb#6
class Rouge::Lexers::Racket < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/racket.rb#65
    def builtins; end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/racket.rb#14
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/racket.rb#21
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/rescript.rb#8
class Rouge::Lexers::ReScript < ::Rouge::Lexers::OCamlCommon
  class << self
    # source://rouge//lib/rouge/lexers/rescript.rb#15
    def keywords; end

    # source://rouge//lib/rouge/lexers/rescript.rb#23
    def types; end

    # source://rouge//lib/rouge/lexers/rescript.rb#30
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/reasonml.rb#8
class Rouge::Lexers::ReasonML < ::Rouge::Lexers::OCamlCommon
  class << self
    # source://rouge//lib/rouge/lexers/reasonml.rb#15
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/rego.rb#6
class Rouge::Lexers::Rego < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/rego.rb#12
    def constants; end

    # source://rouge//lib/rouge/lexers/rego.rb#18
    def operators; end
  end
end

# source://rouge//lib/rouge/lexers/robot_framework.rb#6
class Rouge::Lexers::RobotFramework < ::Rouge::RegexLexer
  # @return [RobotFramework] a new instance of RobotFramework
  #
  # source://rouge//lib/rouge/lexers/robot_framework.rb#16
  def initialize(opts = T.unsafe(nil)); end

  class << self
    # source://rouge//lib/rouge/lexers/robot_framework.rb#31
    def settings_with_args; end

    # source://rouge//lib/rouge/lexers/robot_framework.rb#23
    def settings_with_keywords; end
  end
end

# source://rouge//lib/rouge/lexers/ruby.rb#6
class Rouge::Lexers::Ruby < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/ruby.rb#18
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/rust.rb#6
class Rouge::Lexers::Rust < ::Rouge::RegexLexer
  # @return [Boolean]
  #
  # source://rouge//lib/rouge/lexers/rust.rb#52
  def macro_closed?; end

  class << self
    # source://rouge//lib/rouge/lexers/rust.rb#35
    def builtins; end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/rust.rb#19
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/rust.rb#23
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/sas.rb#5
class Rouge::Lexers::SAS < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/sas.rb#12
    def data_step_statements; end

    # source://rouge//lib/rouge/lexers/sas.rb#140
    def proc_keywords; end

    # source://rouge//lib/rouge/lexers/sas.rb#122
    def sas_auto_macro_vars; end

    # source://rouge//lib/rouge/lexers/sas.rb#29
    def sas_functions; end

    # source://rouge//lib/rouge/lexers/sas.rb#109
    def sas_macro_functions; end

    # source://rouge//lib/rouge/lexers/sas.rb#94
    def sas_macro_statements; end

    # source://rouge//lib/rouge/lexers/sas.rb#330
    def sas_proc_names; end
  end
end

# source://rouge//lib/rouge/lexers/sml.rb#6
class Rouge::Lexers::SML < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/sml.rb#62
  def token_for_final_id(id); end

  # source://rouge//lib/rouge/lexers/sml.rb#70
  def token_for_id(id); end

  # source://rouge//lib/rouge/lexers/sml.rb#54
  def token_for_id_with_dot(id); end

  class << self
    # source://rouge//lib/rouge/lexers/sml.rb#15
    def keywords; end

    # source://rouge//lib/rouge/lexers/sml.rb#25
    def symbolic_reserved; end
  end
end

# source://rouge//lib/rouge/lexers/sparql.rb#6
class Rouge::Lexers::SPARQL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/sparql.rb#13
    def builtins; end

    # source://rouge//lib/rouge/lexers/sparql.rb#25
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/sqf.rb#6
class Rouge::Lexers::SQF < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/sqf.rb#57
    def commands; end

    # source://rouge//lib/rouge/lexers/sqf.rb#32
    def constants; end

    # source://rouge//lib/rouge/lexers/sqf.rb#25
    def controlflow; end

    # source://rouge//lib/rouge/lexers/sqf.rb#46
    def diag_commands; end

    # source://rouge//lib/rouge/lexers/sqf.rb#19
    def initializers; end

    # source://rouge//lib/rouge/lexers/sqf.rb#39
    def namespaces; end

    # source://rouge//lib/rouge/lexers/sqf.rb#13
    def wordoperators; end
  end
end

# source://rouge//lib/rouge/lexers/sql.rb#6
class Rouge::Lexers::SQL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/sql.rb#13
    def keywords; end

    # source://rouge//lib/rouge/lexers/sql.rb#91
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/ssh.rb#6
class Rouge::Lexers::SSH < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/sass.rb#8
class Rouge::Lexers::Sass < ::Rouge::Lexers::SassCommon
  include ::Rouge::Indentation
end

# shared states with SCSS
#
# source://rouge//lib/rouge/lexers/sass/common.rb#7
class Rouge::Lexers::SassCommon < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/scala.rb#6
class Rouge::Lexers::Scala < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/scheme.rb#6
class Rouge::Lexers::Scheme < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/scheme.rb#22
    def builtins; end

    # source://rouge//lib/rouge/lexers/scheme.rb#14
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/scss.rb#8
class Rouge::Lexers::Scss < ::Rouge::Lexers::SassCommon; end

# source://rouge//lib/rouge/lexers/sed.rb#6
class Rouge::Lexers::Sed < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/sed.rb#52
  def regex; end

  # source://rouge//lib/rouge/lexers/sed.rb#56
  def replacement; end

  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/sed.rb#14
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/sed.rb#18
class Rouge::Lexers::Sed::Regex < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/sed.rb#44
class Rouge::Lexers::Sed::Replacement < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/shell.rb#6
class Rouge::Lexers::Shell < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/shell.rb#19
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/shell.rb#28
Rouge::Lexers::Shell::BUILTINS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/shell.rb#23
Rouge::Lexers::Shell::KEYWORDS = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/sieve.rb#6
class Rouge::Lexers::Sieve < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/sieve.rb#20
    def actions; end

    # control commands (rfc5228 § 3)
    #
    # source://rouge//lib/rouge/lexers/sieve.rb#16
    def controls; end

    # source://rouge//lib/rouge/lexers/sieve.rb#39
    def tests; end
  end
end

# source://rouge//lib/rouge/lexers/slice.rb#8
class Rouge::Lexers::Slice < ::Rouge::Lexers::C
  class << self
    # source://rouge//lib/rouge/lexers/slice.rb#16
    def keywords; end

    # source://rouge//lib/rouge/lexers/slice.rb#25
    def keywords_type; end
  end
end

# A lexer for the Slim tempalte language
#
# @see http://slim-lang.org
#
# source://rouge//lib/rouge/lexers/slim.rb#8
class Rouge::Lexers::Slim < ::Rouge::RegexLexer
  include ::Rouge::Indentation

  # source://rouge//lib/rouge/lexers/slim.rb#32
  def filters; end

  # source://rouge//lib/rouge/lexers/slim.rb#28
  def html; end

  # source://rouge//lib/rouge/lexers/slim.rb#24
  def ruby; end
end

# source://rouge//lib/rouge/lexers/smalltalk.rb#6
class Rouge::Lexers::Smalltalk < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/smarty.rb#6
class Rouge::Lexers::Smarty < ::Rouge::TemplateLexer
  class << self
    # source://rouge//lib/rouge/lexers/smarty.rb#14
    def builtins; end
  end
end

# source://rouge//lib/rouge/lexers/solidity.rb#5
class Rouge::Lexers::Solidity < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/solidity.rb#33
    def builtins; end

    # source://rouge//lib/rouge/lexers/solidity.rb#59
    def constants; end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/solidity.rb#16
    def detect?(text); end

    # TODO: seperate by "type"
    #
    # source://rouge//lib/rouge/lexers/solidity.rb#21
    def keywords; end

    # source://rouge//lib/rouge/lexers/solidity.rb#66
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/solidity.rb#72
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/stan.rb#6
class Rouge::Lexers::Stan < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/stan.rb#90
    def builtin_functions; end

    # source://rouge//lib/rouge/lexers/stan.rb#333
    def constants; end

    # source://rouge//lib/rouge/lexers/stan.rb#268
    def distributions; end

    # source://rouge//lib/rouge/lexers/stan.rb#48
    def keywords; end

    # source://rouge//lib/rouge/lexers/stan.rb#62
    def reserved; end

    # source://rouge//lib/rouge/lexers/stan.rb#54
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/stan.rb#14
Rouge::Lexers::Stan::ID = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/stan.rb#16
Rouge::Lexers::Stan::OP = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/stan.rb#15
Rouge::Lexers::Stan::RT = T.let(T.unsafe(nil), Regexp)

# optional comment or whitespace
#
# source://rouge//lib/rouge/lexers/stan.rb#13
Rouge::Lexers::Stan::WS = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/stata.rb#6
class Rouge::Lexers::Stata < ::Rouge::RegexLexer
  class << self
    # Stata commands used with braces. Includes all valid abbreviations for 'forvalues'.
    #
    # source://rouge//lib/rouge/lexers/stata.rb#90
    def reserved_keywords; end

    # Note: types `str1-str2045` handled separately below
    #
    # source://rouge//lib/rouge/lexers/stata.rb#85
    def type_keywords; end
  end
end

# Partial list of common programming and estimation commands, as of Stata 16
# Note: not all abbreviations are included
#
# source://rouge//lib/rouge/lexers/stata.rb#19
Rouge::Lexers::Stata::KEYWORDS = T.let(T.unsafe(nil), Array)

# Complete list of functions by name, as of Stata 16
#
# source://rouge//lib/rouge/lexers/stata.rb#48
Rouge::Lexers::Stata::PRIMITIVE_FUNCTIONS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/supercollider.rb#6
class Rouge::Lexers::SuperCollider < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/supercollider.rb#28
    def constants; end

    # source://rouge//lib/rouge/lexers/supercollider.rb#13
    def keywords; end

    # these aren't technically keywords, but we treat
    # them as such because it makes things clearer 99%
    # of the time
    #
    # source://rouge//lib/rouge/lexers/supercollider.rb#22
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/swift.rb#6
class Rouge::Lexers::Swift < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/systemd.rb#6
class Rouge::Lexers::SystemD < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/syzlang.rb#6
class Rouge::Lexers::Syzlang < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/syzlang.rb#11
    def keywords; end

    # source://rouge//lib/rouge/lexers/syzlang.rb#19
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/syzprog.rb#6
class Rouge::Lexers::Syzprog < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/syzprog.rb#11
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/tcl.rb#6
class Rouge::Lexers::TCL < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/tcl.rb#13
    def detect?(text); end

    # source://rouge//lib/rouge/lexers/tcl.rb#58
    def gen_command_state(name = T.unsafe(nil)); end

    # source://rouge//lib/rouge/lexers/tcl.rb#82
    def gen_delimiter_states(name, close, opts = T.unsafe(nil)); end
  end
end

# source://rouge//lib/rouge/lexers/tcl.rb#40
Rouge::Lexers::TCL::ALL = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/tcl.rb#26
Rouge::Lexers::TCL::BUILTINS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/tcl.rb#44
Rouge::Lexers::TCL::CHARS = T.let(T.unsafe(nil), Proc)

# source://rouge//lib/rouge/lexers/tcl.rb#39
Rouge::Lexers::TCL::CLOSE = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/tcl.rb#41
Rouge::Lexers::TCL::END_LINE = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/tcl.rb#42
Rouge::Lexers::TCL::END_WORD = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/tcl.rb#19
Rouge::Lexers::TCL::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/tcl.rb#45
Rouge::Lexers::TCL::NOT_CHARS = T.let(T.unsafe(nil), Proc)

# source://rouge//lib/rouge/lexers/tcl.rb#38
Rouge::Lexers::TCL::OPEN = T.let(T.unsafe(nil), Array)

# source://rouge//lib/rouge/lexers/toml.rb#6
class Rouge::Lexers::TOML < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/tsx.rb#9
class Rouge::Lexers::TSX < ::Rouge::Lexers::JSX
  extend ::Rouge::Lexers::TypescriptCommon
end

# source://rouge//lib/rouge/lexers/ttcn3.rb#6
class Rouge::Lexers::TTCN3 < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/ttcn3.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/ttcn3.rb#32
    def reserved; end

    # source://rouge//lib/rouge/lexers/ttcn3.rb#42
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/tap.rb#5
class Rouge::Lexers::Tap < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/tex.rb#6
class Rouge::Lexers::TeX < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/tex.rb#15
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/terraform.rb#8
class Rouge::Lexers::Terraform < ::Rouge::Lexers::Hcl
  class << self
    # source://rouge//lib/rouge/lexers/terraform.rb#36
    def builtins; end

    # source://rouge//lib/rouge/lexers/terraform.rb#32
    def constants; end

    # source://rouge//lib/rouge/lexers/terraform.rb#22
    def declarations; end

    # source://rouge//lib/rouge/lexers/terraform.rb#16
    def keywords; end

    # source://rouge//lib/rouge/lexers/terraform.rb#28
    def reserved; end
  end
end

# source://rouge//lib/rouge/lexers/tulip.rb#5
class Rouge::Lexers::Tulip < ::Rouge::RegexLexer
  class << self
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/tulip.rb#14
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/turtle.rb#6
class Rouge::Lexers::Turtle < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/twig.rb#8
class Rouge::Lexers::Twig < ::Rouge::Lexers::Jinja
  class << self
    # source://rouge//lib/rouge/lexers/twig.rb#18
    def keywords; end

    # source://rouge//lib/rouge/lexers/twig.rb#31
    def pseudo_keywords; end

    # source://rouge//lib/rouge/lexers/twig.rb#26
    def tests; end

    # source://rouge//lib/rouge/lexers/twig.rb#35
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/typescript.rb#9
class Rouge::Lexers::Typescript < ::Rouge::Lexers::Javascript
  extend ::Rouge::Lexers::TypescriptCommon
end

# source://rouge//lib/rouge/lexers/typescript/common.rb#6
module Rouge::Lexers::TypescriptCommon
  # source://rouge//lib/rouge/lexers/typescript/common.rb#27
  def builtins; end

  # source://rouge//lib/rouge/lexers/typescript/common.rb#14
  def declarations; end

  # source://rouge//lib/rouge/lexers/typescript/common.rb#7
  def keywords; end

  # source://rouge//lib/rouge/lexers/typescript/common.rb#20
  def reserved; end

  class << self
    # @private
    #
    # source://rouge//lib/rouge/lexers/typescript/common.rb#33
    def extended(base); end
  end
end

# source://rouge//lib/rouge/lexers/vhdl.rb#6
class Rouge::Lexers::VHDL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/vhdl.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/vhdl.rb#27
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/vhdl.rb#35
    def operator_words; end
  end
end

# source://rouge//lib/rouge/lexers/vala.rb#6
class Rouge::Lexers::Vala < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/varnish.rb#6
class Rouge::Lexers::Varnish < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/varnish.rb#28
    def functions; end

    # backend acl
    #
    # source://rouge//lib/rouge/lexers/varnish.rb#18
    def keywords; end

    # source://rouge//lib/rouge/lexers/varnish.rb#39
    def variables; end
  end
end

# source://rouge//lib/rouge/lexers/varnish.rb#15
Rouge::Lexers::Varnish::SPACE = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/lexers/velocity.rb#5
class Rouge::Lexers::Velocity < ::Rouge::TemplateLexer; end

# source://rouge//lib/rouge/lexers/verilog.rb#6
class Rouge::Lexers::Verilog < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/verilog.rb#15
    def keywords; end

    # source://rouge//lib/rouge/lexers/verilog.rb#52
    def keywords_system_task; end

    # source://rouge//lib/rouge/lexers/verilog.rb#37
    def keywords_type; end
  end
end

# source://rouge//lib/rouge/lexers/viml.rb#6
class Rouge::Lexers::VimL < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/viml.rb#16
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/vb.rb#6
class Rouge::Lexers::VisualBasic < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/vb.rb#47
    def builtins; end

    # source://rouge//lib/rouge/lexers/vb.rb#14
    def keywords; end

    # source://rouge//lib/rouge/lexers/vb.rb#33
    def keywords_type; end

    # source://rouge//lib/rouge/lexers/vb.rb#40
    def operator_words; end
  end
end

# source://rouge//lib/rouge/lexers/vue.rb#7
class Rouge::Lexers::Vue < ::Rouge::Lexers::HTML
  # @return [Vue] a new instance of Vue
  #
  # source://rouge//lib/rouge/lexers/vue.rb#15
  def initialize(*_arg0); end

  # source://rouge//lib/rouge/lexers/vue.rb#20
  def lookup_lang(lang); end
end

# source://rouge//lib/rouge/lexers/wollok.rb#6
class Rouge::Lexers::Wollok < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/xml.rb#6
class Rouge::Lexers::XML < ::Rouge::RegexLexer
  class << self
    # Documentation: https://www.w3.org/TR/xml11/#charsets and https://www.w3.org/TR/xml11/#sec-suggested-names
    #
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/xml.rb#17
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/xpath.rb#6
class Rouge::Lexers::XPath < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/xpath.rb#67
    def axes; end

    # source://rouge//lib/rouge/lexers/xpath.rb#46
    def commentStart; end

    # source://rouge//lib/rouge/lexers/xpath.rb#92
    def constructorTypes; end

    # source://rouge//lib/rouge/lexers/xpath.rb#18
    def decimalLiteral; end

    # Terminal literals:
    # https://www.w3.org/TR/xpath-31/#terminal-symbols
    #
    # source://rouge//lib/rouge/lexers/xpath.rb#14
    def digits; end

    # source://rouge//lib/rouge/lexers/xpath.rb#22
    def doubleLiteral; end

    # source://rouge//lib/rouge/lexers/xpath.rb#42
    def eqName; end

    # source://rouge//lib/rouge/lexers/xpath.rb#79
    def keywords; end

    # Terminal symbols:
    # https://www.w3.org/TR/xpath-30/#id-terminal-delimitation
    #
    # source://rouge//lib/rouge/lexers/xpath.rb#56
    def kindTest; end

    # source://rouge//lib/rouge/lexers/xpath.rb#63
    def kindTestForPI; end

    # source://rouge//lib/rouge/lexers/xpath.rb#30
    def ncName; end

    # source://rouge//lib/rouge/lexers/xpath.rb#50
    def openParen; end

    # source://rouge//lib/rouge/lexers/xpath.rb#75
    def operators; end

    # source://rouge//lib/rouge/lexers/xpath.rb#34
    def qName; end

    # source://rouge//lib/rouge/lexers/xpath.rb#26
    def stringLiteral; end

    # source://rouge//lib/rouge/lexers/xpath.rb#38
    def uriQName; end

    # source://rouge//lib/rouge/lexers/xpath.rb#83
    def word_operators; end
  end
end

# source://rouge//lib/rouge/lexers/xquery.rb#7
class Rouge::Lexers::XQuery < ::Rouge::Lexers::XPath
  class << self
    # source://rouge//lib/rouge/lexers/xquery.rb#14
    def keywords; end
  end
end

# source://rouge//lib/rouge/lexers/xojo.rb#6
class Rouge::Lexers::Xojo < ::Rouge::RegexLexer; end

# source://rouge//lib/rouge/lexers/yaml.rb#6
class Rouge::Lexers::YAML < ::Rouge::RegexLexer
  # source://rouge//lib/rouge/lexers/yaml.rb#64
  def continue_indent(match); end

  # @return [Boolean]
  #
  # source://rouge//lib/rouge/lexers/yaml.rb#39
  def dedent?(level); end

  # source://rouge//lib/rouge/lexers/yaml.rb#34
  def indent; end

  # @return [Boolean]
  #
  # source://rouge//lib/rouge/lexers/yaml.rb#43
  def indent?(level); end

  # reset the indentation levels
  #
  # source://rouge//lib/rouge/lexers/yaml.rb#27
  def reset_indent; end

  # Save a possible indentation level
  #
  # source://rouge//lib/rouge/lexers/yaml.rb#48
  def save_indent(match); end

  # source://rouge//lib/rouge/lexers/yaml.rb#69
  def set_indent(match, opts = T.unsafe(nil)); end

  class << self
    # Documentation: https://yaml.org/spec/1.2/spec.html
    #
    # @return [Boolean]
    #
    # source://rouge//lib/rouge/lexers/yaml.rb#16
    def detect?(text); end
  end
end

# source://rouge//lib/rouge/lexers/yaml.rb#21
Rouge::Lexers::YAML::SPECIAL_VALUES = T.let(T.unsafe(nil), Regexp)

# source://rouge//lib/rouge/lexers/yang.rb#6
class Rouge::Lexers::YANG < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/yang.rb#40
    def body_stmts_keywords; end

    # RFC7950 other keywords
    #
    # source://rouge//lib/rouge/lexers/yang.rb#69
    def constants_keywords; end

    # source://rouge//lib/rouge/lexers/yang.rb#47
    def data_def_stmts_keywords; end

    # source://rouge//lib/rouge/lexers/yang.rb#34
    def linkage_stmts_keywords; end

    # source://rouge//lib/rouge/lexers/yang.rb#62
    def list_stmts_keywords; end

    # source://rouge//lib/rouge/lexers/yang.rb#28
    def meta_stmts_keywords; end

    # source://rouge//lib/rouge/lexers/yang.rb#22
    def module_header_stmts_keywords; end

    # Keywords from RFC7950 ; oriented at BNF style
    #
    # source://rouge//lib/rouge/lexers/yang.rb#16
    def top_stmts_keywords; end

    # source://rouge//lib/rouge/lexers/yang.rb#54
    def type_stmts_keywords; end

    # RFC7950 Built-In Types
    #
    # source://rouge//lib/rouge/lexers/yang.rb#77
    def types; end
  end
end

# source://rouge//lib/rouge/lexers/zig.rb#6
class Rouge::Lexers::Zig < ::Rouge::RegexLexer
  class << self
    # source://rouge//lib/rouge/lexers/zig.rb#28
    def builtins; end

    # source://rouge//lib/rouge/lexers/zig.rb#15
    def keywords; end
  end
end

# A stateful lexer that uses sets of regular expressions to
# tokenize a string.  Most lexers are instances of RegexLexer.
#
# @abstract
#
# source://rouge//lib/rouge/regex_lexer.rb#8
class Rouge::RegexLexer < ::Rouge::Lexer
  # Delegate the lex to another lexer. We use the `continue_lex` method
  # so that #reset! will not be called.  In this way, a single lexer
  # can be repeatedly delegated to while maintaining its own internal
  # state stack.
  #
  # @param lexer [#lex] The lexer or lexer class to delegate to
  # @param text [String] The text to delegate.  This defaults to the last matched string.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#420
  def delegate(lexer, text = T.unsafe(nil)); end

  # @private
  #
  # source://rouge//lib/rouge/regex_lexer.rb#268
  def get_state(state_name); end

  # replace the head of the stack with the given state
  #
  # source://rouge//lib/rouge/regex_lexer.rb#464
  def goto(state_name); end

  # Yield a token with the next matched group.  Subsequent calls
  # to this method will yield subsequent groups.
  #
  # @deprecated
  #
  # source://rouge//lib/rouge/regex_lexer.rb#399
  def group(tok); end

  # Yield tokens corresponding to the matched groups of the current
  # match.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#405
  def groups(*tokens); end

  # Check if `state_name` is in the state stack.
  #
  # @return [Boolean]
  #
  # source://rouge//lib/rouge/regex_lexer.rb#479
  def in_state?(state_name); end

  # Pop the state stack.  If a number is passed in, it will be popped
  # that number of times.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#453
  def pop!(times = T.unsafe(nil)); end

  # Push a state onto the stack.  If no state name is given and you've
  # passed a block, a state will be dynamically created using the
  # {StateDSL}.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#437
  def push(state_name = T.unsafe(nil), &b); end

  # source://rouge//lib/rouge/regex_lexer.rb#430
  def recurse(text = T.unsafe(nil)); end

  # reset this lexer to its initial state.  This runs all of the
  # start_procs.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#289
  def reset!; end

  # reset the stack back to `[:root]`.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#472
  def reset_stack; end

  # The state stack.  This is initially the single state `[:root]`.
  # It is an error for this stack to be empty.
  #
  # @see #state
  #
  # source://rouge//lib/rouge/regex_lexer.rb#275
  def stack; end

  # The current state - i.e. one on top of the state stack.
  #
  # NB: if the state stack is empty, this will throw an error rather
  # than returning nil.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#283
  def state; end

  # Check if `state_name` is the state on top of the state stack.
  #
  # @return [Boolean]
  #
  # source://rouge//lib/rouge/regex_lexer.rb#487
  def state?(state_name); end

  # Runs one step of the lex.  Rules in the current state are tried
  # until one matches, at which point its callback is called.
  #
  # @return true if a rule was tried successfully
  # @return false otherwise.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#345
  def step(state, stream); end

  # This implements the lexer protocol, by yielding [token, value] pairs.
  #
  # The process for lexing works as follows, until the stream is empty:
  #
  # 1. We look at the state on top of the stack (which by default is
  #    `[:root]`).
  # 2. Each rule in that state is tried until one is successful.  If one
  #    is found, that rule's callback is evaluated - which may yield
  #    tokens and manipulate the state stack.  Otherwise, one character
  #    is consumed with an `'Error'` token, and we continue at (1.)
  #
  # @see #step #step (where (2.) is implemented)
  #
  # source://rouge//lib/rouge/regex_lexer.rb#311
  def stream_tokens(str, &b); end

  # Yield a token.
  #
  # @param tok the token type
  # @param val (optional) the string value to yield.  If absent, this defaults
  #   to the entire last match.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#391
  def token(tok, val = T.unsafe(nil)); end

  private

  # source://rouge//lib/rouge/regex_lexer.rb#492
  def yield_token(tok, val); end

  class << self
    # source://rouge//lib/rouge/regex_lexer.rb#251
    def append(name, &b); end

    # @private
    #
    # source://rouge//lib/rouge/regex_lexer.rb#258
    def get_state(name); end

    # source://rouge//lib/rouge/regex_lexer.rb#245
    def prepend(name, &b); end

    # source://rouge//lib/rouge/regex_lexer.rb#218
    def replace_state(name, new_defn); end

    # Specify an action to be run every fresh lex.
    #
    # @example
    #   start { puts "I'm lexing a new string!" }
    #
    # source://rouge//lib/rouge/regex_lexer.rb#234
    def start(&b); end

    # The routines to run at the beginning of a fresh lex.
    #
    # @see start
    #
    # source://rouge//lib/rouge/regex_lexer.rb#225
    def start_procs; end

    # Define a new state for this lexer with the given name.
    # The block will be evaluated in the context of a {StateDSL}.
    #
    # source://rouge//lib/rouge/regex_lexer.rb#240
    def state(name, &b); end

    # source://rouge//lib/rouge/regex_lexer.rb#213
    def state_definitions; end

    # The states hash for this lexer.
    #
    # @see state
    #
    # source://rouge//lib/rouge/regex_lexer.rb#209
    def states; end
  end
end

# source://rouge//lib/rouge/regex_lexer.rb#19
class Rouge::RegexLexer::ClosedState < ::StandardError
  # @return [ClosedState] a new instance of ClosedState
  #
  # source://rouge//lib/rouge/regex_lexer.rb#21
  def initialize(state); end

  # source://rouge//lib/rouge/regex_lexer.rb#25
  def rule; end

  # Returns the value of attribute state.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#20
  def state; end

  # source://rouge//lib/rouge/regex_lexer.rb#29
  def to_s; end
end

# source://rouge//lib/rouge/regex_lexer.rb#9
class Rouge::RegexLexer::InvalidRegex < ::StandardError
  # @return [InvalidRegex] a new instance of InvalidRegex
  #
  # source://rouge//lib/rouge/regex_lexer.rb#10
  def initialize(re); end

  # source://rouge//lib/rouge/regex_lexer.rb#14
  def to_s; end
end

# The number of successive scans permitted without consuming
# the input stream.  If this is exceeded, the match fails.
#
# source://rouge//lib/rouge/regex_lexer.rb#338
Rouge::RegexLexer::MAX_NULL_SCANS = T.let(T.unsafe(nil), Integer)

# A rule is a tuple of a regular expression to test, and a callback
# to perform if the test succeeds.
#
# @see StateDSL#rule
#
# source://rouge//lib/rouge/regex_lexer.rb#44
class Rouge::RegexLexer::Rule
  # @return [Rule] a new instance of Rule
  #
  # source://rouge//lib/rouge/regex_lexer.rb#48
  def initialize(re, callback); end

  # Returns the value of attribute beginning_of_line.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#47
  def beginning_of_line; end

  # Returns the value of attribute callback.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#45
  def callback; end

  # source://rouge//lib/rouge/regex_lexer.rb#54
  def inspect; end

  # Returns the value of attribute re.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#46
  def re; end
end

# a State is a named set of rules that can be tested for or
# mixed in.
#
# @see RegexLexer.state
#
# source://rouge//lib/rouge/regex_lexer.rb#63
class Rouge::RegexLexer::State
  # @return [State] a new instance of State
  #
  # source://rouge//lib/rouge/regex_lexer.rb#65
  def initialize(name, rules); end

  # source://rouge//lib/rouge/regex_lexer.rb#70
  def inspect; end

  # Returns the value of attribute name.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#64
  def name; end

  # Returns the value of attribute rules.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#64
  def rules; end
end

# source://rouge//lib/rouge/regex_lexer.rb#75
class Rouge::RegexLexer::StateDSL
  # @return [StateDSL] a new instance of StateDSL
  #
  # source://rouge//lib/rouge/regex_lexer.rb#77
  def initialize(name, &defn); end

  # source://rouge//lib/rouge/regex_lexer.rb#101
  def appended(&defn); end

  # Returns the value of attribute name.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#76
  def name; end

  # source://rouge//lib/rouge/regex_lexer.rb#93
  def prepended(&defn); end

  # Returns the value of attribute rules.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#76
  def rules; end

  # source://rouge//lib/rouge/regex_lexer.rb#85
  def to_state(lexer_class); end

  protected

  # source://rouge//lib/rouge/regex_lexer.rb#188
  def close!; end

  # @return [Boolean]
  #
  # source://rouge//lib/rouge/regex_lexer.rb#178
  def context_sensitive?(re); end

  # Mix in the rules from another state into this state.  The rules
  # from the mixed-in state will be tried in order before moving on
  # to the rest of the rules in this state.
  #
  # source://rouge//lib/rouge/regex_lexer.rb#195
  def mixin(state); end

  # Define a new rule for this state.
  #
  # @overload rule
  # @overload rule
  # @param re [Regexp] a regular expression for this rule to test.
  # @param tok [String] the token type to yield if `re` matches.
  # @param next_state [#to_s] (optional) a state to push onto the stack if `re` matches.
  #   If `next_state` is `:pop!`, the state stack will be popped
  #   instead.
  # @param callback [Proc] a block that will be evaluated in the context of the lexer
  #   if `re` matches.  This block has access to a number of lexer
  #   methods, including {RegexLexer#push}, {RegexLexer#pop!},
  #   {RegexLexer#token}, and {RegexLexer#delegate}.  The first
  #   argument can be used to access the match groups.
  # @raise [ClosedState]
  #
  # source://rouge//lib/rouge/regex_lexer.rb#129
  def rule(re, tok = T.unsafe(nil), next_state = T.unsafe(nil), &callback); end

  private

  # source://rouge//lib/rouge/regex_lexer.rb#200
  def load!; end
end

# A TemplateLexer is one that accepts a :parent option, to specify
# which language is being templated.  The lexer class can specify its
# own default for the parent lexer, which is otherwise defaulted to
# HTML.
#
# @abstract
#
# source://rouge//lib/rouge/template_lexer.rb#10
class Rouge::TemplateLexer < ::Rouge::RegexLexer
  # the parent lexer - the one being templated.
  #
  # source://rouge//lib/rouge/template_lexer.rb#12
  def parent; end
end

# source://rouge//lib/rouge/tex_theme_renderer.rb#5
class Rouge::TexThemeRenderer
  # @return [TexThemeRenderer] a new instance of TexThemeRenderer
  #
  # source://rouge//lib/rouge/tex_theme_renderer.rb#6
  def initialize(theme, opts = T.unsafe(nil)); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#97
  def camelize(name); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#86
  def gen_inline(name, &b); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#70
  def inline_name(color); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#101
  def palette_name(name); end

  # Our general strategy is this:
  #
  # * First, define the \RG{tokname}{content} command, which will
  #   expand into \RG@tok@tokname{content}. We use \csname...\endcsname
  #   to interpolate into a command.
  #
  # * Define the default RG* environment, which will enclose the whole
  #   thing. By default this will simply set \ttfamily (select monospace font)
  #   but it can be overridden with \renewcommand by the user to be
  #   any other formatting.
  #
  # * Define all the colors using xcolors \definecolor command. First we define
  #   every palette color with a name such as RG@palette@themneame@colorname.
  #   Then we find all foreground and background colors that have literal html
  #   colors embedded in them and define them with names such as
  #   RG@palette@themename@000000. While html allows three-letter colors such
  #   as #FFF, xcolor requires all six characters to be present, so we make sure
  #   to normalize that as well as the case convention in #inline_name.
  #
  # * Define the token commands RG@tok@xx. These will take the content as the
  #   argument and format it according to the theme, referring to the color
  #   in the palette.
  #
  # @yield [<<'END'.gsub('RG', @prefix)
  # \makeatletter
  # \def\RG#1#2{\csname RG@tok@#1\endcsname{#2}}%
  # \newenvironment{RG*}{\ttfamily}{\relax}%
  # END]
  #
  # source://rouge//lib/rouge/tex_theme_renderer.rb#33
  def render(&b); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#111
  def render_blank(tok, &b); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#65
  def render_inline_pallete(style, &b); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#57
  def render_palette(palette, &b); end

  # @yield [out]
  #
  # source://rouge//lib/rouge/tex_theme_renderer.rb#115
  def render_style(tok, style, &b); end

  # source://rouge//lib/rouge/tex_theme_renderer.rb#107
  def token_name(tok); end
end

# source://rouge//lib/rouge/text_analyzer.rb#5
class Rouge::TextAnalyzer < ::String
  # Return the contents of the doctype tag if present, nil otherwise.
  #
  # source://rouge//lib/rouge/text_analyzer.rb#25
  def doctype; end

  # Check if the doctype matches a given regexp or string
  #
  # @return [Boolean]
  #
  # source://rouge//lib/rouge/text_analyzer.rb#36
  def doctype?(type = T.unsafe(nil)); end

  # Return true if the result of lexing with the given lexer contains no
  # error tokens.
  #
  # @return [Boolean]
  #
  # source://rouge//lib/rouge/text_analyzer.rb#42
  def lexes_cleanly?(lexer); end

  # Find a shebang.  Returns nil if no shebang is present.
  #
  # source://rouge//lib/rouge/text_analyzer.rb#7
  def shebang; end

  # Check if the given shebang is present.
  #
  # This normalizes things so that `text.shebang?('bash')` will detect
  # `#!/bash`, '#!/bin/bash', '#!/usr/bin/env bash', and '#!/bin/bash -x'
  #
  # @return [Boolean]
  #
  # source://rouge//lib/rouge/text_analyzer.rb#18
  def shebang?(match); end
end

# source://rouge//lib/rouge/theme.rb#5
class Rouge::Theme
  include ::Rouge::Token::Tokens

  # source://rouge//lib/rouge/theme.rb#78
  def get_own_style(token); end

  # source://rouge//lib/rouge/theme.rb#82
  def get_style(token); end

  # source://rouge//lib/rouge/theme.rb#86
  def name; end

  # source://rouge//lib/rouge/theme.rb#67
  def palette(*a); end

  # source://rouge//lib/rouge/theme.rb#46
  def styles; end

  class << self
    # source://rouge//lib/rouge/theme.rb#111
    def base_style; end

    # source://rouge//lib/rouge/theme.rb#126
    def find(n); end

    # source://rouge//lib/rouge/theme.rb#99
    def get_own_style(token); end

    # source://rouge//lib/rouge/theme.rb#107
    def get_style(token); end

    # source://rouge//lib/rouge/theme.rb#115
    def name(n = T.unsafe(nil)); end

    # source://rouge//lib/rouge/theme.rb#51
    def palette(arg = T.unsafe(nil)); end

    # source://rouge//lib/rouge/theme.rb#122
    def register(name); end

    # source://rouge//lib/rouge/theme.rb#130
    def registry; end

    # source://rouge//lib/rouge/theme.rb#74
    def render(opts = T.unsafe(nil), &b); end

    # source://rouge//lib/rouge/theme.rb#91
    def style(*tokens); end

    # source://rouge//lib/rouge/theme.rb#70
    def styles; end
  end
end

# source://rouge//lib/rouge/theme.rb#8
class Rouge::Theme::Style < ::Hash
  # @return [Style] a new instance of Style
  #
  # source://rouge//lib/rouge/theme.rb#9
  def initialize(theme, hsh = T.unsafe(nil)); end

  # source://rouge//lib/rouge/theme.rb#16
  def bg; end

  # source://rouge//lib/rouge/theme.rb#16
  def fg; end

  # @yield ["#{selector} {"]
  #
  # source://rouge//lib/rouge/theme.rb#22
  def render(selector, &b); end

  # @yield ["color: #{fg}"]
  #
  # source://rouge//lib/rouge/theme.rb#34
  def rendered_rules(&b); end
end

# source://rouge//lib/rouge/themes/thankful_eyes.rb#5
module Rouge::Themes; end

# default base16 theme
# by Chris Kempson (http://chriskempson.com)
#
# source://rouge//lib/rouge/themes/base16.rb#8
class Rouge::Themes::Base16 < ::Rouge::CSSTheme
  extend ::Rouge::HasModes

  class << self
    # source://rouge//lib/rouge/themes/base16.rb#35
    def dark!; end

    # source://rouge//lib/rouge/themes/base16.rb#30
    def light!; end

    # source://rouge//lib/rouge/themes/base16.rb#40
    def make_dark!; end

    # source://rouge//lib/rouge/themes/base16.rb#44
    def make_light!; end
  end
end

# source://rouge//lib/rouge/themes/base16.rb#108
class Rouge::Themes::Base16::Monokai < ::Rouge::Themes::Base16; end

# source://rouge//lib/rouge/themes/base16.rb#85
class Rouge::Themes::Base16::Solarized < ::Rouge::Themes::Base16; end

# A port of the bw style from Pygments.
# See https://bitbucket.org/birkenfeld/pygments-main/src/default/pygments/styles/bw.py
#
# source://rouge//lib/rouge/themes/bw.rb#8
class Rouge::Themes::BlackWhiteTheme < ::Rouge::CSSTheme; end

# stolen from pygments
#
# source://rouge//lib/rouge/themes/colorful.rb#7
class Rouge::Themes::Colorful < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/github.rb#6
class Rouge::Themes::Github < ::Rouge::CSSTheme; end

# Based on https://github.com/morhetz/gruvbox, with help from
# https://github.com/daveyarwood/gruvbox-pygments
#
# source://rouge//lib/rouge/themes/gruvbox.rb#10
class Rouge::Themes::Gruvbox < ::Rouge::CSSTheme
  extend ::Rouge::HasModes

  class << self
    # source://rouge//lib/rouge/themes/gruvbox.rb#67
    def dark!; end

    # source://rouge//lib/rouge/themes/gruvbox.rb#62
    def light!; end

    # source://rouge//lib/rouge/themes/gruvbox.rb#72
    def make_dark!; end

    # source://rouge//lib/rouge/themes/gruvbox.rb#99
    def make_light!; end
  end
end

# source://rouge//lib/rouge/themes/gruvbox.rb#40
Rouge::Themes::Gruvbox::C_bright_aqua = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#38
Rouge::Themes::Gruvbox::C_bright_blue = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#36
Rouge::Themes::Gruvbox::C_bright_green = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#41
Rouge::Themes::Gruvbox::C_bright_orange = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#39
Rouge::Themes::Gruvbox::C_bright_purple = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#35
Rouge::Themes::Gruvbox::C_bright_red = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#37
Rouge::Themes::Gruvbox::C_bright_yellow = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#15
Rouge::Themes::Gruvbox::C_dark0 = T.let(T.unsafe(nil), String)

# global Gruvbox colours {{{
#
# source://rouge//lib/rouge/themes/gruvbox.rb#14
Rouge::Themes::Gruvbox::C_dark0_hard = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#16
Rouge::Themes::Gruvbox::C_dark0_soft = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#17
Rouge::Themes::Gruvbox::C_dark1 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#18
Rouge::Themes::Gruvbox::C_dark2 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#19
Rouge::Themes::Gruvbox::C_dark3 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#20
Rouge::Themes::Gruvbox::C_dark4 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#21
Rouge::Themes::Gruvbox::C_dark4_256 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#56
Rouge::Themes::Gruvbox::C_faded_aqua = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#54
Rouge::Themes::Gruvbox::C_faded_blue = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#52
Rouge::Themes::Gruvbox::C_faded_green = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#57
Rouge::Themes::Gruvbox::C_faded_orange = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#55
Rouge::Themes::Gruvbox::C_faded_purple = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#51
Rouge::Themes::Gruvbox::C_faded_red = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#53
Rouge::Themes::Gruvbox::C_faded_yellow = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#24
Rouge::Themes::Gruvbox::C_gray_244 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#23
Rouge::Themes::Gruvbox::C_gray_245 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#27
Rouge::Themes::Gruvbox::C_light0 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#26
Rouge::Themes::Gruvbox::C_light0_hard = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#28
Rouge::Themes::Gruvbox::C_light0_soft = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#29
Rouge::Themes::Gruvbox::C_light1 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#30
Rouge::Themes::Gruvbox::C_light2 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#31
Rouge::Themes::Gruvbox::C_light3 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#32
Rouge::Themes::Gruvbox::C_light4 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#33
Rouge::Themes::Gruvbox::C_light4_256 = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#48
Rouge::Themes::Gruvbox::C_neutral_aqua = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#46
Rouge::Themes::Gruvbox::C_neutral_blue = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#44
Rouge::Themes::Gruvbox::C_neutral_green = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#49
Rouge::Themes::Gruvbox::C_neutral_orange = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#47
Rouge::Themes::Gruvbox::C_neutral_purple = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#43
Rouge::Themes::Gruvbox::C_neutral_red = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/gruvbox.rb#45
Rouge::Themes::Gruvbox::C_neutral_yellow = T.let(T.unsafe(nil), String)

# source://rouge//lib/rouge/themes/igor_pro.rb#6
class Rouge::Themes::IgorPro < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/magritte.rb#6
class Rouge::Themes::Magritte < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/molokai.rb#6
class Rouge::Themes::Molokai < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/monokai.rb#6
class Rouge::Themes::Monokai < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/monokai_sublime.rb#6
class Rouge::Themes::MonokaiSublime < ::Rouge::CSSTheme; end

# A port of the pastie style from Pygments.
# See https://bitbucket.org/birkenfeld/pygments-main/src/default/pygments/styles/pastie.py
#
# source://rouge//lib/rouge/themes/pastie.rb#8
class Rouge::Themes::Pastie < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/thankful_eyes.rb#6
class Rouge::Themes::ThankfulEyes < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/themes/tulip.rb#6
class Rouge::Themes::Tulip < ::Rouge::CSSTheme; end

# source://rouge//lib/rouge/token.rb#5
class Rouge::Token
  class << self
    # source://rouge//lib/rouge/token.rb#19
    def [](qualname); end

    # source://rouge//lib/rouge/token.rb#11
    def cache; end

    # source://rouge//lib/rouge/token.rb#62
    def each_token(&b); end

    # source://rouge//lib/rouge/token.rb#25
    def inspect; end

    # source://rouge//lib/rouge/token.rb#46
    def make_token(name, shortname, &b); end

    # @return [Boolean]
    #
    # source://rouge//lib/rouge/token.rb#29
    def matches?(other); end

    # Returns the value of attribute name.
    #
    # source://rouge//lib/rouge/token.rb#7
    def name; end

    # Returns the value of attribute parent.
    #
    # source://rouge//lib/rouge/token.rb#8
    def parent; end

    # source://rouge//lib/rouge/token.rb#37
    def qualname; end

    # source://rouge//lib/rouge/token.rb#41
    def register!; end

    # Returns the value of attribute shortname.
    #
    # source://rouge//lib/rouge/token.rb#9
    def shortname; end

    # source://rouge//lib/rouge/token.rb#15
    def sub_tokens; end

    # source://rouge//lib/rouge/token.rb#57
    def token(name, shortname, &b); end

    # source://rouge//lib/rouge/token.rb#33
    def token_chain; end
  end
end

# source://rouge//lib/rouge/token.rb#69
module Rouge::Token::Tokens
  class << self
    # source://rouge//lib/rouge/token.rb#70
    def token(name, shortname, &b); end
  end
end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment::Doc < ::Rouge::Token::Tokens::Comment; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment::Hashbang < ::Rouge::Token::Tokens::Comment; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment::Multiline < ::Rouge::Token::Tokens::Comment; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment::Preproc < ::Rouge::Token::Tokens::Comment; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment::PreprocFile < ::Rouge::Token::Tokens::Comment; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment::Single < ::Rouge::Token::Tokens::Comment; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Comment::Special < ::Rouge::Token::Tokens::Comment; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Error < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Escape < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Deleted < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Emph < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Error < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Heading < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Inserted < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Lineno < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Output < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Prompt < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Strong < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Subheading < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Generic::Traceback < ::Rouge::Token::Tokens::Generic; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword::Constant < ::Rouge::Token::Tokens::Keyword; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword::Declaration < ::Rouge::Token::Tokens::Keyword; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword::Namespace < ::Rouge::Token::Tokens::Keyword; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword::Pseudo < ::Rouge::Token::Tokens::Keyword; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword::Reserved < ::Rouge::Token::Tokens::Keyword; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword::Type < ::Rouge::Token::Tokens::Keyword; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Keyword::Variable < ::Rouge::Token::Tokens::Keyword; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Date < ::Rouge::Token::Tokens::Literal; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number < ::Rouge::Token::Tokens::Literal; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number::Bin < ::Rouge::Token::Tokens::Literal::Number; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number::Float < ::Rouge::Token::Tokens::Literal::Number; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number::Hex < ::Rouge::Token::Tokens::Literal::Number; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number::Integer < ::Rouge::Token::Tokens::Literal::Number; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number::Integer::Long < ::Rouge::Token::Tokens::Literal::Number::Integer; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number::Oct < ::Rouge::Token::Tokens::Literal::Number; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::Number::Other < ::Rouge::Token::Tokens::Literal::Number; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String < ::Rouge::Token::Tokens::Literal; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Affix < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Backtick < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Char < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Delimiter < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Doc < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Double < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Escape < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Heredoc < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Interpol < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Other < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Regex < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Single < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Literal::String::Symbol < ::Rouge::Token::Tokens::Literal::String; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Attribute < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Builtin < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Builtin::Pseudo < ::Rouge::Token::Tokens::Name::Builtin; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Class < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Constant < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Decorator < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Entity < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Exception < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Function < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Function::Magic < ::Rouge::Token::Tokens::Name::Function; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Label < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Namespace < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Other < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Property < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Tag < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Variable < ::Rouge::Token::Tokens::Name; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Variable::Class < ::Rouge::Token::Tokens::Name::Variable; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Variable::Global < ::Rouge::Token::Tokens::Name::Variable; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Variable::Instance < ::Rouge::Token::Tokens::Name::Variable; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Name::Variable::Magic < ::Rouge::Token::Tokens::Name::Variable; end

# convenience
#
# source://rouge//lib/rouge/token.rb#187
Rouge::Token::Tokens::Num = Rouge::Token::Tokens::Literal::Number

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Operator < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Operator::Word < ::Rouge::Token::Tokens::Operator; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Other < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Punctuation < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Punctuation::Indicator < ::Rouge::Token::Tokens::Punctuation; end

# source://rouge//lib/rouge/token.rb#188
Rouge::Token::Tokens::Str = Rouge::Token::Tokens::Literal::String

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Text < ::Rouge::Token; end

# source://rouge//lib/rouge/token.rb#48
class Rouge::Token::Tokens::Text::Whitespace < ::Rouge::Token::Tokens::Text; end
