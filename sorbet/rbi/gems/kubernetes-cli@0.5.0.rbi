# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `kubernetes-cli` gem.
# Please instead update this file by running `bin/tapioca gem kubernetes-cli`.


# source://kubernetes-cli//lib/kubernetes-cli.rb#9
# typed: strong
class KubernetesCLI
  extend T::Sig

  # T::Sig::WithoutRuntime.sig { params(kubeconfig_path: String, executable: String).void }
  #
  # @return [KubernetesCLI] a new instance of KubernetesCLI
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#68
  sig { params(kubeconfig_path: String, executable: String).void }
  def initialize(kubeconfig_path, executable = T.unsafe(nil)); end

  # T::Sig::WithoutRuntime.sig { params(block: AfterCallback).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#82
  sig { params(block: AfterCallback).void }
  def after_execute(&block); end

  # T::Sig::WithoutRuntime.sig {
  #   params(
  #     type: String,
  #     namespace: String,
  #     name: String,
  #     annotations: T::Hash[String, String],
  #     overwrite: T::Boolean
  #   ).void
  # }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#337
  sig do
    params(
      type: String,
      namespace: String,
      name: String,
      annotations: T::Hash[String, String],
      overwrite: T::Boolean
    ).void
  end
  def annotate(type, namespace, name, annotations, overwrite: T.unsafe(nil)); end

  # T::Sig::WithoutRuntime.sig { returns(String) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#382
  sig { returns(String) }
  def api_resources; end

  # T::Sig::WithoutRuntime.sig { params(res: ::KubeDSL::DSLObject, dry_run: T::Boolean).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#159
  sig { params(res: ::KubeDSL::DSLObject, dry_run: T::Boolean).void }
  def apply(res, dry_run: T.unsafe(nil)); end

  # T::Sig::WithoutRuntime.sig { params(uri: String, dry_run: T::Boolean).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#179
  sig { params(uri: String, dry_run: T::Boolean).void }
  def apply_uri(uri, dry_run: T.unsafe(nil)); end

  # T::Sig::WithoutRuntime.sig { params(block: BeforeCallback).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#77
  sig { params(block: BeforeCallback).void }
  def before_execute(&block); end

  # T::Sig::WithoutRuntime.sig { returns(String) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#376
  sig { returns(String) }
  def current_context; end

  # T::Sig::WithoutRuntime.sig {
  #   params(
  #     type: String,
  #     namespace: String,
  #     name: String
  #   ).void
  # }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#261
  sig { params(type: String, namespace: String, name: String).void }
  def delete_object(type, namespace, name); end

  # T::Sig::WithoutRuntime.sig {
  #   params(
  #     type: String,
  #     namespace: T.any(String, Symbol),
  #     match_labels: T::Hash[String, String]
  #   ).void
  # }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#281
  sig { params(type: String, namespace: T.any(String, Symbol), match_labels: T::Hash[String, String]).void }
  def delete_objects(type, namespace, match_labels = T.unsafe(nil)); end

  # T::Sig::WithoutRuntime.sig { returns(T::Hash[String, String]) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#444
  sig { returns(T::Hash[String, String]) }
  def env; end

  # T::Sig::WithoutRuntime.sig {
  #   params(
  #     container_cmd: T.any(String, T::Array[String]),
  #     namespace: String,
  #     pod: String,
  #     tty: T::Boolean,
  #     container: T.nilable(String),
  #     out_file: T.nilable(String)
  #   ).void
  # }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#132
  sig do
    params(
      container_cmd: T.any(String, T::Array[String]),
      namespace: String,
      pod: String,
      tty: T::Boolean,
      container: T.nilable(String),
      out_file: T.nilable(String)
    ).void
  end
  def exec_cmd(container_cmd, namespace, pod, tty = T.unsafe(nil), container = T.unsafe(nil), out_file = T.unsafe(nil)); end

  # T::Sig::WithoutRuntime.sig { returns(String) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#60
  def executable; end

  # T::Sig::WithoutRuntime.sig {
  #   params(
  #     type: String,
  #     namespace: String,
  #     name: String
  #   ).returns(
  #     T::Hash[String, T.untyped]
  #   )
  # }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#204
  sig { params(type: String, namespace: String, name: String).returns(T::Hash[String, T.untyped]) }
  def get_object(type, namespace, name); end

  # T::Sig::WithoutRuntime.sig {
  #   params(
  #     type: String,
  #     namespace: T.any(String, Symbol),
  #     match_labels: T::Hash[String, String]
  #   ).returns(
  #     T::Array[T.untyped]
  #   )
  # }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#229
  sig do
    params(
      type: String,
      namespace: T.any(String, Symbol),
      match_labels: T::Hash[String, String]
    ).returns(T::Array[T.untyped])
  end
  def get_objects(type, namespace, match_labels = T.unsafe(nil)); end

  # T::Sig::WithoutRuntime.sig { returns(String) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#57
  def kubeconfig_path; end

  # T::Sig::WithoutRuntime.sig { returns(T.nilable(Process::Status)) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#87
  sig { returns(T.nilable(Process::Status)) }
  def last_status; end

  # T::Sig::WithoutRuntime.sig {
  #   params(
  #     namespace: String,
  #     selector: T::Hash[String, String],
  #     follow: T::Boolean
  #   ).void
  # }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#367
  sig { params(namespace: String, selector: T::Hash[String, String], follow: T::Boolean).void }
  def logtail(namespace, selector, follow: T.unsafe(nil)); end

  # T::Sig::WithoutRuntime.sig { params(block: T.proc.params(last_status: Process::Status).void).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#97
  sig { params(block: T.proc.params(last_status: Process::Status).void).void }
  def on_last_status_failure(&block); end

  # T::Sig::WithoutRuntime.sig {
  #   params(
  #     type: String,
  #     namespace: String,
  #     name: String,
  #     patch_data: String,
  #     patch_type: String
  #   ).void
  # }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#313
  sig { params(type: String, namespace: String, name: String, patch_data: String, patch_type: String).void }
  def patch_object(type, namespace, name, patch_data, patch_type = T.unsafe(nil)); end

  # T::Sig::WithoutRuntime.sig { params(namespace: String, deployment: String).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#395
  sig { params(namespace: String, deployment: String).void }
  def restart_deployment(namespace, deployment); end

  # T::Sig::WithoutRuntime.sig { params(cmd: T.any(String, T::Array[String])).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#117
  sig { params(cmd: T.any(String, T::Array[String])).void }
  def run_cmd(cmd); end

  # T::Sig::WithoutRuntime.sig { returns(T.any(StringIO, IO)) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#434
  sig { returns(T.any(StringIO, IO)) }
  def stderr; end

  # T::Sig::WithoutRuntime.sig { params(new_stderr: T.nilable(T.any(StringIO, IO))).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#439
  sig { params(new_stderr: T.nilable(T.any(StringIO, IO))).void }
  def stderr=(new_stderr); end

  # T::Sig::WithoutRuntime.sig { returns(T.any(StringIO, IO)) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#424
  sig { returns(T.any(StringIO, IO)) }
  def stdout; end

  # T::Sig::WithoutRuntime.sig { params(new_stdout: T.nilable(T.any(StringIO, IO))).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#429
  sig { params(new_stdout: T.nilable(T.any(StringIO, IO))).void }
  def stdout=(new_stdout); end

  # T::Sig::WithoutRuntime.sig {
  #   params(
  #     container_cmd: T.any(String, T::Array[String]),
  #     namespace: String,
  #     pod: String,
  #     tty: T::Boolean,
  #     container: T.nilable(String)
  #   ).void
  # }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#150
  sig do
    params(
      container_cmd: T.any(String, T::Array[String]),
      namespace: String,
      pod: String,
      tty: T::Boolean,
      container: T.nilable(String)
    ).void
  end
  def system_cmd(container_cmd, namespace, pod, tty = T.unsafe(nil), container = T.unsafe(nil)); end

  # T::Sig::WithoutRuntime.sig { returns(T::Hash[T.untyped, T.untyped]) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#104
  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def version; end

  # T::Sig::WithoutRuntime.sig { params(block: T.proc.params(last_status: Process::Status).void).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#92
  sig { params(block: T.proc.params(last_status: Process::Status).void).void }
  def with_last_status(&block); end

  # T::Sig::WithoutRuntime.sig { params(out: T.any(StringIO, IO), err: T.any(StringIO, IO), block: T.proc.void).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#412
  sig { params(out: T.any(StringIO, IO), err: T.any(StringIO, IO), block: T.proc.void).void }
  def with_pipes(out = T.unsafe(nil), err = T.unsafe(nil), &block); end

  private

  # T::Sig::WithoutRuntime.sig { params(cmd: T::Array[String]).returns(String) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#509
  sig { params(cmd: T::Array[String]).returns(String) }
  def backticks(cmd); end

  # T::Sig::WithoutRuntime.sig { params(cmd: T::Array[String]).returns(String) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#514
  sig { params(cmd: T::Array[String]).returns(String) }
  def backticks_open3(cmd); end

  # T::Sig::WithoutRuntime.sig { returns(T::Array[String]) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#451
  sig { returns(T::Array[String]) }
  def base_cmd; end

  # T::Sig::WithoutRuntime.sig { params(cmd: T::Array[String]).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#456
  sig { params(cmd: T::Array[String]).void }
  def execc(cmd); end

  # T::Sig::WithoutRuntime.sig { params(status: Process::Status).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#592
  sig { params(status: Process::Status).void }
  def last_status=(status); end

  # T::Sig::WithoutRuntime.sig {
  #   params(
  #     env: T::Hash[String, String],
  #     cmd: T::Array[String],
  #     opts: T::Hash[Symbol, T.untyped],
  #     block: T.proc.params(p_stdin: IO).void
  #   ).void
  # }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#551
  sig do
    params(
      env: T::Hash[String, String],
      cmd: T::Array[String],
      opts: T::Hash[Symbol, T.untyped],
      block: T.proc.params(p_stdin: IO).void
    ).void
  end
  def open3_w(env, cmd, opts = T.unsafe(nil), &block); end

  # T::Sig::WithoutRuntime.sig { params(cmd: T::Array[String]).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#587
  sig { params(cmd: T::Array[String]).void }
  def run_after_callbacks(cmd); end

  # T::Sig::WithoutRuntime.sig { params(cmd: T::Array[String]).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#582
  sig { params(cmd: T::Array[String]).void }
  def run_before_callbacks(cmd); end

  # T::Sig::WithoutRuntime.sig { params(cmd: T::Array[String]).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#463
  sig { params(cmd: T::Array[String]).void }
  def systemm(cmd); end

  # T::Sig::WithoutRuntime.sig { params(cmd: T::Array[String]).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#472
  sig { params(cmd: T::Array[String]).void }
  def systemm_default(cmd); end

  # T::Sig::WithoutRuntime.sig { params(cmd: T::Array[String]).void }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#482
  sig { params(cmd: T::Array[String]).void }
  def systemm_open3(cmd); end

  AfterCallback = T.type_alias { T.proc.params(cmd: T::Array[String], last_status: Process::Status).void }
  BeforeCallback = T.type_alias { T.proc.params(cmd: T::Array[String]).void }
end

# source://kubernetes-cli//lib/kubernetes-cli.rb#49
class KubernetesCLI::AnnotateResourceError < ::KubernetesCLI::KubernetesError; end

# source://kubernetes-cli//lib/kubernetes-cli.rb#47
class KubernetesCLI::DeleteResourceError < ::KubernetesCLI::KubernetesError; end

# source://kubernetes-cli//lib/kubernetes-cli.rb#46
class KubernetesCLI::GetResourceError < ::KubernetesCLI::KubernetesError; end

# source://kubernetes-cli//lib/kubernetes-cli.rb#50
class KubernetesCLI::GetVersionError < ::KubernetesCLI::KubernetesError; end

# source://kubernetes-cli//lib/kubernetes-cli.rb#14
class KubernetesCLI::InvalidResourceError < ::KubernetesCLI::KubernetesError
  extend T::Sig

  # T::Sig::WithoutRuntime.sig { params(args: T.untyped).void }
  #
  # @return [InvalidResourceError] a new instance of InvalidResourceError
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#24
  sig { params(args: T.untyped).void }
  def initialize(*args); end

  # T::Sig::WithoutRuntime.sig { returns(T.nilable(::KubeDSL::DSLObject)) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#18
  def resource; end

  # T::Sig::WithoutRuntime.sig { params(resource: ::KubeDSL::DSLObject).returns(::KubeDSL::DSLObject) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#21
  def resource=(_arg0); end
end

# source://kubernetes-cli//lib/kubernetes-cli.rb#30
class KubernetesCLI::InvalidResourceUriError < ::KubernetesCLI::KubernetesError
  extend T::Sig

  # T::Sig::WithoutRuntime.sig { params(args: T.untyped).void }
  #
  # @return [InvalidResourceUriError] a new instance of InvalidResourceUriError
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#40
  sig { params(args: T.untyped).void }
  def initialize(*args); end

  # T::Sig::WithoutRuntime.sig { returns(T.nilable(String)) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#34
  def resource_uri; end

  # T::Sig::WithoutRuntime.sig { params(resource_uri: String).returns(String) }
  #
  # source://kubernetes-cli//lib/kubernetes-cli.rb#37
  def resource_uri=(_arg0); end
end

# extend T::Sig
#
# source://kubernetes-cli//lib/kubernetes-cli.rb#12
class KubernetesCLI::KubernetesError < ::StandardError; end

# source://kubernetes-cli//lib/kubernetes-cli.rb#48
class KubernetesCLI::PatchResourceError < ::KubernetesCLI::KubernetesError; end

# source://kubernetes-cli//lib/kubernetes-cli.rb#52
KubernetesCLI::STATUS_KEY = T.let(T.unsafe(nil), Symbol)

# source://kubernetes-cli//lib/kubernetes-cli.rb#54
KubernetesCLI::STDERR_KEY = T.let(T.unsafe(nil), Symbol)

# source://kubernetes-cli//lib/kubernetes-cli.rb#53
KubernetesCLI::STDOUT_KEY = T.let(T.unsafe(nil), Symbol)
