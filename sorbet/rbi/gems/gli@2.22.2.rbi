# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `gli` gem.
# Please instead update this file by running `bin/tapioca gem gli`.


# source://gli//lib/gli/command_finder.rb#1
module GLI
  include ::GLI::DSL
  include ::GLI::AppSupport
  include ::GLI::App

  class << self
    # @private
    #
    # source://gli//lib/gli.rb#28
    def included(klass); end

    # source://gli//lib/gli.rb#32
    def run(*args); end
  end
end

# The command issued partially matches more than one command
#
# source://gli//lib/gli/exceptions.rb#39
class GLI::AmbiguousCommand < ::GLI::BadCommandLine; end

# A means to define and parse a command line interface that works as
# Git's does, in that you specify global options, a command name, command
# specific options, and then command arguments.
#
# source://gli//lib/gli/app.rb#10
module GLI::App
  include ::GLI::DSL
  include ::GLI::AppSupport

  # Configure a type conversion not already provided by the underlying OptionParser.
  # This works more or less like the OptionParser version. It's global.
  #
  # object:: the class (or whatever) that triggers the type conversion
  # block:: the block that will be given the string argument and is expected
  #         to return the converted value
  #
  # Example
  #
  #     accept(Hash) do |value|
  #       result = {}
  #       value.split(/,/).each do |pair|
  #         k,v = pair.split(/:/)
  #         result[k] = v
  #       end
  #       result
  #     end
  #
  #     flag :properties, :type => Hash
  #
  # source://gli//lib/gli/app.rb#212
  def accept(object, &block); end

  # How to handle argument validation.
  #
  # handling_strategy:: One of:
  #                     +:loose+:: no argument validation.  Use of `arg` or `arg_name` is for documentation purposes only.  (Default)
  #                     +:strict+:: arguments are validated according to their specification.  +action+ blocks may assume
  #                                 the value of `arguments` matches the specification provided in `arg`.  Note that to use
  #                                 this strategy, you must also be sure that +subcommand_option_handling+ is set.
  #
  # source://gli//lib/gli/app.rb#301
  def arguments(handling_strategy); end

  # This inverts the pre/post concept.  This is useful when you have a global shared resource that is governed by a block
  # instead of separate open/close methods.  The block you pass here will be given four parameters:
  #
  # global options:: the parsed global options
  # command:: The GLI::Command that the user is going to invoke
  # options:: the command specific options
  # args:: unparsed command-line args
  # code:: a block that you must +call+ to execute the command.
  #
  # #help_now! and #exit_now! work as expected; you can abort the command call by simply not calling it.
  #
  # You can declare as many #around blocks as you want.  They will be called in the order in which they are defined.
  #
  # Note that if you declare #around blocks, #pre and #post blocks will still work.  The #pre is called first, followed by
  # the around, followed by the #post.
  #
  # Call #skips_around before a command that should not have this hook fired
  #
  # source://gli//lib/gli/app.rb#147
  def around(&a_proc); end

  # Enables/Disables command autocomplete, where partially spelled commands are automatically expanded to their full form
  #
  # Example:
  # When enabled, executing 'shake' would execute 'shake_hand' (if no 'shake' command is defined).
  # When disabled, executing 'shake' would throw an UnknownCommand error
  #
  # +boolean+:: Boolean value to enable or disable autocomplete, respectively. True by default.
  #
  # source://gli//lib/gli/app.rb#313
  def autocomplete_commands(boolean); end

  # Loads ruby files in the load path that start with
  # +path+, which are presumed to be commands for your executable.
  # This is useful for decomposing your bin file into different classes, but
  # can also be used as a plugin mechanism, allowing users to provide additional
  # commands for your app at runtime.  All that being said, it's basically
  # a glorified +require+.
  #
  # path:: a path from which to load <code>.rb</code> files that, presumably, contain commands.  If this is an absolute path,
  #        any files in that path are loaded.  If not, it is interpretted as relative to somewhere
  #        in the <code>LOAD_PATH</code>.
  #
  # == Example:
  #
  #     # loads *.rb from your app's install - great for decomposing your bin file
  #     commands_from "my_app/commands"
  #
  #     # loads *.rb files from the user's home dir - great and an extension/plugin mechanism
  #     commands_from File.join(ENV["HOME"],".my_app","plugins")
  #
  # source://gli//lib/gli/app.rb#32
  def commands_from(path); end

  # Sets that this app uses a config file as well as the name of the config file.
  #
  # +filename+:: A String representing the path to the file to use for the config file.  If it's an absolute
  #              path, this is treated as the path to the file.  If it's *not*, it's treated as relative to the user's home
  #              directory as produced by <code>File.expand_path('~')</code>.
  #
  # source://gli//lib/gli/app.rb#102
  def config_file(filename); end

  # Sets a default command to run when none is specified on the command line.  Note that
  # if you use this, you won't be able to pass arguments, flags, or switches
  # to the command when run in default mode.  All flags and switches are treated
  # as global, and any argument will be interpretted as the command name and likely
  # fail.
  #
  # +command+:: Command as a Symbol to run as default
  #
  # source://gli//lib/gli/app.rb#280
  def default_command(command); end

  # Simpler means of exiting with a custom exit code.  This will
  # raise a CustomExit with the given message and exit code, which will ultimatley
  # cause your application to exit with the given exit_code as its exit status
  # Use #help_now! if you want to show the help in addition to the error message
  #
  # message:: message to show the user
  # exit_code:: exit code to exit as, defaults to 1
  #
  # @raise [CustomExit]
  #
  # source://gli//lib/gli/app.rb#223
  def exit_now!(message, exit_code = T.unsafe(nil)); end

  # Exit now, showing the user help for the command they executed.  Use #exit_now! to just show the error message
  #
  # message:: message to indicate how the user has messed up the CLI invocation or nil to just simply show help
  #
  # source://gli//lib/gli/app.rb#230
  def help_now!(message = T.unsafe(nil)); end

  # Provide a flag to choose whether to hide or not from the help the undescribed commands.
  # By default the undescribed commands will be shown in the help.
  #
  # hide:: A Bool for hide the undescribed commands
  #
  # source://gli//lib/gli/app.rb#69
  def hide_commands_without_desc(hide = T.unsafe(nil)); end

  # Define a block to run if an error occurs.
  # The block will receive any Exception that was caught.
  # It should evaluate to false to avoid the built-in error handling (which basically just
  # prints out a message). GLI uses a variety of exceptions that you can use to find out what
  # errors might've occurred during command-line parsing:
  # * GLI::CustomExit
  # * GLI::UnknownCommandArgument
  # * GLI::UnknownGlobalArgument
  # * GLI::UnknownCommand
  # * GLI::BadCommandLine
  #
  # source://gli//lib/gli/app.rb#162
  def on_error(&a_proc); end

  # Define a block to run after the command was executed, <b>only
  # if there was not an error</b>.
  # The block will receive the global-options,command,options, and arguments
  #
  # source://gli//lib/gli/app.rb#126
  def post(&a_proc); end

  # Define a block to run after command line arguments are parsed
  # but before any command is run.  If this block raises an exception
  # the command specified will not be executed.
  # The block will receive the global-options,command,options, and arguments
  # If this block evaluates to true, the program will proceed; otherwise
  # the program will end immediately and exit nonzero
  #
  # source://gli//lib/gli/app.rb#119
  def pre(&a_proc); end

  # By default, GLI mutates the argument passed to it.  This is
  # consistent with +OptionParser+, but be less than ideal.  Since
  # that value, for scaffolded apps, is +ARGV+, you might want to
  # refer to the entire command-line via +ARGV+ and thus not want it mutated.
  #
  # source://gli//lib/gli/app.rb#179
  def preserve_argv(preserve = T.unsafe(nil)); end

  # Describe the overall application/programm.  This should be a one-sentence summary
  # of what your program does that will appear in the help output.
  #
  # +description+:: A String of the short description of your program's purpose
  #
  # source://gli//lib/gli/app.rb#47
  def program_desc(description = T.unsafe(nil)); end

  # Provide a longer description of the program.  This can be as long as needed, and use double-newlines
  # for paragraphs.  This will show up in the help output.
  #
  # description:: A String for the description
  #
  # source://gli//lib/gli/app.rb#58
  def program_long_desc(description = T.unsafe(nil)); end

  # source://gli//lib/gli/app.rb#269
  def program_name(override = T.unsafe(nil)); end

  # Use this if the following command should not have the around block executed.
  # By default, the around block is executed, but for commands that might not want the
  # setup to happen, this can be handy
  #
  # source://gli//lib/gli/app.rb#93
  def skips_around; end

  # Use this if the following command should not have the post block executed.
  # By default, the post block is executed after each command.
  # Using this will avoid that behavior for the following command
  #
  # source://gli//lib/gli/app.rb#86
  def skips_post; end

  # Use this if the following command should not have the pre block executed.
  # By default, the pre block is executed before each command and can result in
  # aborting the call.  Using this will avoid that behavior for the following command
  #
  # source://gli//lib/gli/app.rb#79
  def skips_pre; end

  # Control how commands and options are sorted in help output.  By default, they are sorted alphabetically.
  #
  # sort_type:: How you want help commands/options sorted:
  #             +:manually+:: help commands/options are ordered in the order declared.
  #             +:alpha+:: sort alphabetically (default)
  #
  # source://gli//lib/gli/app.rb#243
  def sort_help(sort_type); end

  # How to handle subcommand options.  In general, you want to set this to +:normal+, which
  # treats each subcommand as establishing its own namespace for options.  This is what
  # the scaffolding should generate, but it is *not* what GLI 2.5.x and lower apps had as a default.
  # To maintain backwards compatibility, the default is +:legacy+, which is that all subcommands of
  # a particular command share a namespace for options, making it impossible for two subcommands
  # to have options of the same name.
  #
  # source://gli//lib/gli/app.rb#290
  def subcommand_option_handling(handling_strategy); end

  # Control how the SYNOPSIS is formatted.
  #
  # format:: one of:
  #          +:full+:: the default, show subcommand options and flags inline
  #          +:terminal+:: if :full would be wider than the terminal, use :compact
  #          +:compact+:: use a simpler and shorter SYNOPSIS.  Useful if your app has a lot of options and showing them in the SYNOPSIS makes things more confusing
  #
  # source://gli//lib/gli/app.rb#265
  def synopsis_format(format); end

  # Call this with +true+ will cause the +global_options+ and
  # +options+ passed to your code to be wrapped in
  # Options, which is a subclass of +OpenStruct+ that adds
  # <tt>[]</tt> and <tt>[]=</tt> methods.
  #
  # +use_openstruct+:: a Boolean indicating if we should use OpenStruct instead of Hashes
  #
  # source://gli//lib/gli/app.rb#189
  def use_openstruct(use_openstruct); end

  # Indicate the version of your application
  #
  # +version+:: String containing the version of your application.
  #
  # source://gli//lib/gli/app.rb#169
  def version(version); end

  # Set how help text is wrapped.
  #
  # wrap_type:: Symbol indicating how you'd like text wrapped:
  #             +:to_terminal+:: Wrap text based on the width of the terminal (default)
  #             +:verbatim+:: Format text exactly as it was given to the various methods.  This is useful if your output has
  #                           formatted output, e.g. ascii tables and you don't want it messed with.
  #             +:one_line+:: Do not wrap text at all.  This will bring all help content onto one line, removing any newlines
  #             +:tty_only+:: Wrap like +:to_terminal+ if this output is going to a TTY, otherwise don't wrap (like +:one_line+)
  #
  # source://gli//lib/gli/app.rb#255
  def wrap_help_text(wrap_type); end

  private

  # source://gli//lib/gli/app.rb#319
  def load_commands(path); end
end

# Internals for make App work
#
# source://gli//lib/gli/app_support.rb#3
module GLI::AppSupport
  # source://gli//lib/gli/app_support.rb#103
  def accepts; end

  # source://gli//lib/gli/app_support.rb#210
  def argument_handling_strategy; end

  # source://gli//lib/gli/app_support.rb#163
  def around_blocks; end

  # source://gli//lib/gli/app_support.rb#218
  def autocomplete; end

  # source://gli//lib/gli/app_support.rb#119
  def clear_nexts; end

  # source://gli//lib/gli/app_support.rb#142
  def commands; end

  # Get an array of commands, ordered by when they were declared
  #
  # source://gli//lib/gli/app_support.rb#42
  def commands_declaration_order; end

  # Return the name of the config file; mostly useful for generating help docs
  #
  # source://gli//lib/gli/app_support.rb#100
  def config_file_name; end

  # source://gli//lib/gli/app_support.rb#9
  def context_description; end

  # Override the device of stderr; exposed only for testing
  #
  # source://gli//lib/gli/app_support.rb#5
  def error_device=(e); end

  # source://gli//lib/gli/app_support.rb#37
  def exe_name; end

  # source://gli//lib/gli/app_support.rb#134
  def flags; end

  # Get the default command for the entire app
  #
  # source://gli//lib/gli/app_support.rb#52
  def get_default_command; end

  # source://gli//lib/gli/app_support.rb#167
  def help_sort_type; end

  # source://gli//lib/gli/app_support.rb#171
  def help_text_wrap_type; end

  # source://gli//lib/gli/app_support.rb#187
  def override_command_defaults(command_list, config); end

  # source://gli//lib/gli/app_support.rb#204
  def override_default(tokens, config); end

  # Sets the default values for flags based on the configuration
  #
  # source://gli//lib/gli/app_support.rb#180
  def override_defaults_based_on_config(config); end

  # source://gli//lib/gli/app_support.rb#108
  def parse_config; end

  # source://gli//lib/gli/app_support.rb#158
  def post_block; end

  # source://gli//lib/gli/app_support.rb#152
  def pre_block; end

  # Reset the GLI module internal data structures; mostly useful for testing
  #
  # source://gli//lib/gli/app_support.rb#14
  def reset; end

  # Runs whatever command is needed based on the arguments.
  #
  # +args+:: the command line ARGV array
  #
  # Returns a number that would be a reasonable exit code
  #
  # source://gli//lib/gli/app_support.rb#61
  def run(args); end

  # source://gli//lib/gli/app_support.rb#126
  def stderr; end

  # source://gli//lib/gli/app_support.rb#214
  def subcommand_option_handling_strategy; end

  # source://gli//lib/gli/app_support.rb#138
  def switches; end

  # source://gli//lib/gli/app_support.rb#175
  def synopsis_format_type; end

  # Get the version string
  #
  # source://gli//lib/gli/app_support.rb#47
  def version_string; end

  private

  # source://gli//lib/gli/app_support.rb#255
  def add_help_switch_if_needed(target); end

  # source://gli//lib/gli/app_support.rb#292
  def call_command(parsing_result); end

  # Returns a String of the error message to show the user
  # +ex+:: The exception we caught that launched the error handling routines
  #
  # source://gli//lib/gli/app_support.rb#288
  def error_message(ex); end

  # source://gli//lib/gli/app_support.rb#224
  def handle_exception(ex, command); end

  # @return [Boolean]
  #
  # source://gli//lib/gli/app_support.rb#250
  def no_message_given?(ex); end

  # source://gli//lib/gli/app_support.rb#243
  def output_error_message(ex); end

  # True if we should proceed with executing the command; this calls
  # the pre block if it's defined
  #
  # @return [Boolean]
  #
  # source://gli//lib/gli/app_support.rb#267
  def proceed?(parsing_result); end

  # Returns true if we should proceed with GLI's basic error handling.
  # This calls the error block if the user provided one
  #
  # @return [Boolean]
  #
  # source://gli//lib/gli/app_support.rb#277
  def regular_error_handling?(ex); end

  class << self
    # @private
    #
    # source://gli//lib/gli/app_support.rb#130
    def included(klass); end
  end
end

# source://gli//lib/gli/argument.rb#2
class GLI::Argument
  # @return [Argument] a new instance of Argument
  #
  # source://gli//lib/gli/argument.rb#7
  def initialize(name, options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://gli//lib/gli/argument.rb#16
  def multiple?; end

  # Returns the value of attribute name.
  #
  # source://gli//lib/gli/argument.rb#4
  def name; end

  # @return [Boolean]
  #
  # source://gli//lib/gli/argument.rb#12
  def optional?; end

  # Returns the value of attribute options.
  #
  # source://gli//lib/gli/argument.rb#5
  def options; end
end

# Indicates that the command line invocation was bad
#
# source://gli//lib/gli/exceptions.rb#24
class GLI::BadCommandLine < ::StandardError
  include ::GLI::StandardException

  # source://gli//lib/gli/exceptions.rb#26
  def exit_code; end
end

# source://gli//lib/gli/exceptions.rb#62
class GLI::BadCommandOptionsOrArguments < ::GLI::BadCommandLine
  # @return [BadCommandOptionsOrArguments] a new instance of BadCommandOptionsOrArguments
  #
  # source://gli//lib/gli/exceptions.rb#65
  def initialize(message, command); end

  # The command for which the argument was unknown
  #
  # source://gli//lib/gli/exceptions.rb#64
  def command_in_context; end
end

# A command to be run, in context of global flags and switches.  You are given an instance of this class
# to the block you use for GLI::DSL#command.  This class mixes in GLI::DSL so all of those methods are available
# to describe the command, in addition to the methods documented here, most importantly
# #action.
#
# Example:
#
#     command :list do |c| # <- c is an instance of GLI::Command
#       c.desc 'use long form'
#       c.switch :l
#
#       c.action do |global,options,args|
#         # list things here
#       end
#
#       c.command :tasks do |t| # <- t is an instance of GLI::Command
#         # this is a "subcommand" of list
#
#         t.action do |global,options,args|
#           # do whatever list tasks should do
#         end
#       end
#     end
#
# source://gli//lib/gli/command.rb#29
class GLI::Command < ::GLI::CommandLineToken
  include ::GLI::DSL
  include ::GLI::CommandSupport

  # Create a new command.
  #
  # options:: Keys should be:
  #           +names+:: A String, Symbol, or Array of String or Symbol that represents the name(s) of this command (required).
  #           +description+:: short description of this command as a String
  #           +arguments_name+:: description of the arguments as a String, or nil if this command doesn't take arguments
  #           +long_desc+:: a longer description of the command, possibly with multiple lines.  A double line-break is treated
  #                         as a paragraph break.  No other formatting is respected, though inner whitespace is maintained.
  #           +skips_pre+:: if true, this command advertises that it doesn't want the pre block called first
  #           +skips_post+:: if true, this command advertises that it doesn't want the post block called after it
  #           +skips_around+:: if true, this command advertises that it doesn't want the around block called
  #           +hide_commands_without_desc+:: if true and there isn't a description the command is not going to be shown in the help
  #           +examples+:: An array of Hashes, where each hash must have the key +:example+ mapping to a string, and may optionally have the key +:desc+
  #                        that documents that example.
  #
  # @return [Command] a new instance of Command
  #
  # source://gli//lib/gli/command.rb#58
  def initialize(options); end

  # Define the action to take when the user executes this command.  Every command should either define this
  # action block, or have subcommands (or both).
  #
  # +block+:: A block of code to execute.  The block will be given 3 arguments:
  #           +global_options+:: A Hash of the _global_ options specified
  #                              by the user, with defaults set and config file values used (if using a config file, see
  #                              GLI::App#config_file)
  #           +options+:: A Hash of the command-specific options specified by the
  #                       user, with defaults set and config file values used (if using a config file, see
  #                       GLI::App#config_file).
  #           +arguments+:: An Array of Strings representing the unparsed command line arguments
  #           The block's result value is not used; raise an exception or use GLI#exit_now! if you need an early exit based
  #           on an error condition
  #
  # source://gli//lib/gli/command.rb#108
  def action(&block); end

  # Set the default command if this command has subcommands and the user doesn't
  # provide a subcommand when invoking THIS command.  When nil, this will show an error and the help
  # for this command; when set, the command with this name will be executed.
  #
  # +command_name+:: The primary name of the subcommand of this command that should be run by default as a String or Symbol.
  #
  # source://gli//lib/gli/command.rb#90
  def default_command(command_name); end

  # Describes this commands action block when it *also* has subcommands.
  # In this case, the GLI::DSL#desc value is the general description of the commands
  # that this command groups, and the value for *this* method documents what
  # will happen if you omit a subcommand.
  #
  # Note that if you omit the action block and specify a subcommand, that subcommand's
  # description will be used to describe what happens by default.
  #
  # desc:: the description of what this command's action block does.
  #
  # Example
  #
  #     desc 'list things'
  #     command :list do |c|
  #
  #       c.desc 'list tasks'
  #       c.command :tasks do |t|
  #         t.action do |global,options,args|
  #         end
  #       end
  #
  #       c.desc 'list contexts'
  #       c.command :contexts do |t|
  #         t.action do |global,options,args|
  #         end
  #       end
  #
  #       c.default_desc 'list both tasks and contexts'
  #       c.action do |global,options,args|
  #         # list everything
  #       end
  #     end
  #
  #
  #     > todo help list
  #     NAME
  #         list - List things
  #
  #     SYNOPSIS
  #         todo [global options] list [command options]
  #         todo [global options] list [command options]  tasks
  #         todo [global options] list [command options]  contexts
  #
  #     COMMANDS
  #         <default> - list both tasks and contexts
  #         tasks     - list tasks
  #         contexts  - list contexts
  #
  # source://gli//lib/gli/command.rb#160
  def default_desc(desc); end

  # Specify an example invocation.
  #
  # example_invocation:: test of a complete command-line invocation you want to show
  # options:: refine the example:
  #           +:desc+:: A description of the example to be shown with it (optional)
  #
  # source://gli//lib/gli/command.rb#79
  def example(example_invocation, options = T.unsafe(nil)); end

  # Returns true if this command has the given option defined
  #
  # @return [Boolean]
  #
  # source://gli//lib/gli/command.rb#165
  def has_option?(option); end

  # Returns full name for help command including parents
  #
  # Example
  #
  #   command :remote do |t|
  #     t.command :add do |global,options,args|
  #     end
  #   end
  #
  #   @add_command.name_for_help # => ["remote", "add"]
  #
  # source://gli//lib/gli/command.rb#182
  def name_for_help; end

  class << self
    # source://gli//lib/gli/command.rb#192
    def name_as_string(name, negatable = T.unsafe(nil)); end
  end
end

# Key in an options hash to find the parent's parsed options.  Note that if you are
# using openstruct, e.g. via `use_openstruct true` in your app setup, you will need
# to use the method `__parent__` to access parent parsed options.
#
# source://gli//lib/gli/command.rb#42
GLI::Command::PARENT = T.let(T.unsafe(nil), GLI::Command::ParentKey)

# source://gli//lib/gli/command.rb#33
class GLI::Command::ParentKey
  # source://gli//lib/gli/command.rb#34
  def to_sym; end
end

# source://gli//lib/gli/exceptions.rb#46
class GLI::CommandException < ::GLI::BadCommandLine
  # +message+:: the error message to show the user
  # +command+:: the command we were using to parse command-specific options
  #
  # @return [CommandException] a new instance of CommandException
  #
  # source://gli//lib/gli/exceptions.rb#51
  def initialize(message, command_in_context, exit_code = T.unsafe(nil)); end

  # The command for which the argument was unknown
  #
  # source://gli//lib/gli/exceptions.rb#48
  def command_in_context; end

  # source://gli//lib/gli/exceptions.rb#57
  def exit_code; end
end

# source://gli//lib/gli/command_finder.rb#2
class GLI::CommandFinder
  # @return [CommandFinder] a new instance of CommandFinder
  #
  # source://gli//lib/gli/command_finder.rb#10
  def initialize(commands, options = T.unsafe(nil)); end

  # @raise [UnknownCommand]
  #
  # source://gli//lib/gli/command_finder.rb#15
  def find_command(name); end

  # Returns the value of attribute options.
  #
  # source://gli//lib/gli/command_finder.rb#3
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://gli//lib/gli/command_finder.rb#3
  def options=(_arg0); end

  private

  # Returns the value of attribute commands_with_aliases.
  #
  # source://gli//lib/gli/command_finder.rb#39
  def commands_with_aliases; end

  # Sets the attribute commands_with_aliases
  #
  # @param value the value to set the attribute commands_with_aliases to.
  #
  # source://gli//lib/gli/command_finder.rb#39
  def commands_with_aliases=(_arg0); end

  # source://gli//lib/gli/command_finder.rb#41
  def expand_with_aliases(commands); end

  # source://gli//lib/gli/command_finder.rb#52
  def find_command_by_partial_name(commands_with_aliases, command_to_match); end
end

# source://gli//lib/gli/command_finder.rb#5
GLI::CommandFinder::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# An option, not a command or argument, on the command line
#
# source://gli//lib/gli/command_line_option.rb#5
class GLI::CommandLineOption < ::GLI::CommandLineToken
  # Creates a new option
  #
  # names - Array of symbols or strings representing the names of this switch
  # options - hash of options:
  #           :desc - the short description
  #           :long_desc - the long description
  #           :default_value - the default value of this option
  #
  # @return [CommandLineOption] a new instance of CommandLineOption
  #
  # source://gli//lib/gli/command_line_option.rb#18
  def initialize(names, options = T.unsafe(nil)); end

  # Command to which this option "belongs", nil if it's a global option
  #
  # source://gli//lib/gli/command_line_option.rb#9
  def associated_command; end

  # Command to which this option "belongs", nil if it's a global option
  #
  # source://gli//lib/gli/command_line_option.rb#9
  def associated_command=(_arg0); end

  # source://gli//lib/gli/command_line_option.rb#7
  def default_value; end

  # source://gli//lib/gli/command_line_option.rb#7
  def default_value=(_arg0); end

  class << self
    # source://gli//lib/gli/command_line_option.rb#23
    def name_as_string(name, negatable = T.unsafe(nil)); end
  end
end

# Abstract base class for a logical element of a command line, mostly so that subclasses can have similar
# initialization and interface
#
# source://gli//lib/gli/command_line_token.rb#4
class GLI::CommandLineToken
  # @return [CommandLineToken] a new instance of CommandLineToken
  #
  # source://gli//lib/gli/command_line_token.rb#10
  def initialize(names, description, long_description = T.unsafe(nil)); end

  # Sort based on primary name
  #
  # source://gli//lib/gli/command_line_token.rb#17
  def <=>(other); end

  # source://gli//lib/gli/command_line_token.rb#6
  def aliases; end

  # source://gli//lib/gli/command_line_token.rb#7
  def description; end

  # source://gli//lib/gli/command_line_token.rb#8
  def long_description; end

  # source://gli//lib/gli/command_line_token.rb#5
  def name; end

  # Array of the name and aliases, as string
  #
  # source://gli//lib/gli/command_line_token.rb#22
  def names_and_aliases; end

  private

  # Returns a string of all possible forms
  # of this flag.  Mostly intended for printing
  # to the user.
  #
  # source://gli//lib/gli/command_line_token.rb#30
  def all_forms(joiner = T.unsafe(nil)); end

  # source://gli//lib/gli/command_line_token.rb#55
  def all_forms_a; end

  # @return [Boolean]
  #
  # source://gli//lib/gli/command_line_token.rb#51
  def negatable?; end

  # Handles dealing with the "names" param, parsing
  # it into the primary name and aliases list
  #
  # source://gli//lib/gli/command_line_token.rb#38
  def parse_names(names); end
end

# source://gli//lib/gli/gli_option_block_parser.rb#52
class GLI::CommandOptionBlockParser < ::GLI::GLIOptionBlockParser
  # source://gli//lib/gli/gli_option_block_parser.rb#54
  def command=(command_being_parsed); end

  protected

  # @return [Boolean]
  #
  # source://gli//lib/gli/gli_option_block_parser.rb#60
  def break_on_non_option?; end

  # source://gli//lib/gli/gli_option_block_parser.rb#64
  def do_parse(args); end
end

# Things unrelated to the true public interface of Command that are needed for bookkeeping
# and help support.  Generally, you shouldn't be calling these methods; they are technically public
# but are essentially part of GLI's internal implementation and subject to change
#
# source://gli//lib/gli/command_support.rb#5
module GLI::CommandSupport
  # source://gli//lib/gli/command_support.rb#102
  def arg_name(d, options = T.unsafe(nil)); end

  # source://gli//lib/gli/command_support.rb#28
  def arguments; end

  # Return the arguments description
  #
  # source://gli//lib/gli/command_support.rb#20
  def arguments_description; end

  # source://gli//lib/gli/command_support.rb#24
  def arguments_options; end

  # source://gli//lib/gli/command_support.rb#121
  def commands; end

  # Get an array of commands, ordered by when they were declared
  #
  # source://gli//lib/gli/command_support.rb#58
  def commands_declaration_order; end

  # source://gli//lib/gli/command_support.rb#9
  def context_description; end

  # source://gli//lib/gli/command_support.rb#125
  def default_description; end

  # source://gli//lib/gli/command_support.rb#107
  def default_value(d); end

  # source://gli//lib/gli/command_support.rb#92
  def desc(d); end

  # Returns the array of examples
  #
  # source://gli//lib/gli/command_support.rb#53
  def examples; end

  # Executes the command
  #
  # source://gli//lib/gli/command_support.rb#130
  def execute(global_options, options, arguments); end

  # source://gli//lib/gli/command_support.rb#62
  def flag(*names); end

  # Return the flags as a Hash
  #
  # source://gli//lib/gli/command_support.rb#113
  def flags; end

  # source://gli//lib/gli/command_support.rb#148
  def get_default_command; end

  # @return [Boolean]
  #
  # source://gli//lib/gli/command_support.rb#144
  def has_action?; end

  # source://gli//lib/gli/command_support.rb#97
  def long_desc(d); end

  # Return the Array of the command's names
  #
  # source://gli//lib/gli/command_support.rb#48
  def names; end

  # Return true to avoid including this command in your help strings
  # Will honor the hide_commands_without_desc flag
  #
  # source://gli//lib/gli/command_support.rb#15
  def nodoc; end

  # The parent of this command, either the GLI app, or another command
  #
  # source://gli//lib/gli/command_support.rb#7
  def parent; end

  # The parent of this command, either the GLI app, or another command
  #
  # source://gli//lib/gli/command_support.rb#7
  def parent=(_arg0); end

  # If true, this command doesn't want the around block called
  #
  # source://gli//lib/gli/command_support.rb#43
  def skips_around; end

  # If true, this command doesn't want the post block run before it executes
  #
  # source://gli//lib/gli/command_support.rb#38
  def skips_post; end

  # If true, this command doesn't want the pre block run before it executes
  #
  # source://gli//lib/gli/command_support.rb#33
  def skips_pre; end

  # source://gli//lib/gli/command_support.rb#77
  def switch(*names); end

  # Return the switches as a Hash
  #
  # source://gli//lib/gli/command_support.rb#117
  def switches; end

  # source://gli//lib/gli/command_support.rb#134
  def topmost_ancestor; end

  private

  # @return [Boolean]
  #
  # source://gli//lib/gli/command_support.rb#179
  def am_subcommand?; end

  # source://gli//lib/gli/command_support.rb#167
  def generate_error_action(arguments); end

  # source://gli//lib/gli/command_support.rb#159
  def get_action(arguments); end

  # @return [Boolean]
  #
  # source://gli//lib/gli/command_support.rb#183
  def have_subcommands?; end

  # @return [Boolean]
  #
  # source://gli//lib/gli/command_support.rb#154
  def send_declarations_to_parent?; end
end

# source://gli//lib/gli/commands/help_modules/list_formatter.rb#2
module GLI::Commands; end

# A command that calls other commands in order
#
# source://gli//lib/gli/commands/compound_command.rb#4
class GLI::Commands::CompoundCommand < ::GLI::Command
  # base:: object that respondes to +commands+
  # configuration:: Array of arrays: index 0 is the array of names of this command and index 1
  #                 is the names of the compound commands.
  #
  # @return [CompoundCommand] a new instance of CompoundCommand
  #
  # source://gli//lib/gli/commands/compound_command.rb#8
  def initialize(base, configuration, options = T.unsafe(nil)); end

  # source://gli//lib/gli/commands/compound_command.rb#19
  def execute(global_options, options, arguments); end

  private

  # source://gli//lib/gli/commands/compound_command.rb#27
  def check_for_unknown_commands!(base, command_names); end

  class << self
    # source://gli//lib/gli/commands/compound_command.rb#36
    def find_command(base, name); end
  end
end

# Takes a DocListener which will be called with all of the meta-data and documentation
# about your app, so as to create documentation in whatever format you want
#
# source://gli//lib/gli/commands/doc.rb#5
class GLI::Commands::Doc < ::GLI::Command
  # Create the Doc generator based on the GLI app passed in
  #
  # @return [Doc] a new instance of Doc
  #
  # source://gli//lib/gli/commands/doc.rb#10
  def initialize(app); end

  # Generates documentation using the listener
  #
  # source://gli//lib/gli/commands/doc.rb#35
  def document(document_listener); end

  # source://gli//lib/gli/commands/doc.rb#30
  def nodoc; end

  private

  # @return [Boolean]
  #
  # source://gli//lib/gli/commands/doc.rb#232
  def any_commands?(command); end

  # @return [Boolean]
  #
  # source://gli//lib/gli/commands/doc.rb#223
  def any_options?(context); end

  # source://gli//lib/gli/commands/doc.rb#183
  def by_name; end

  # source://gli//lib/gli/commands/doc.rb#165
  def call_command_method_being_backwards_compatible(document_listener, command); end

  # source://gli//lib/gli/commands/doc.rb#187
  def command_flags(command); end

  # source://gli//lib/gli/commands/doc.rb#195
  def command_switches(command); end

  # source://gli//lib/gli/commands/doc.rb#151
  def document_commands(document_listener, context); end

  # source://gli//lib/gli/commands/doc.rb#203
  def document_flags_and_switches(document_listener, flags, switches); end

  # source://gli//lib/gli/commands/doc.rb#141
  def format_class(format_name); end
end

# Interface for a listener that is called during various parts of the doc process
#
# source://gli//lib/gli/commands/doc.rb#56
class GLI::Commands::Doc::DocumentListener
  # @return [DocumentListener] a new instance of DocumentListener
  #
  # source://gli//lib/gli/commands/doc.rb#57
  def initialize(global_options, options, arguments, app); end

  # Called before processing begins
  #
  # source://gli//lib/gli/commands/doc.rb#64
  def beginning; end

  # Gives you a command in the current context and creates a new context of this command
  #
  # source://gli//lib/gli/commands/doc.rb#124
  def command(name, aliases, desc, long_desc, arg_name, arg_options); end

  # Called at the start of commands for the current context
  #
  # source://gli//lib/gli/commands/doc.rb#99
  def commands; end

  # Gives you the name of the current command in the current context
  #
  # source://gli//lib/gli/commands/doc.rb#119
  def default_command(name); end

  # Ends a command, and "pops" you back up one context
  #
  # source://gli//lib/gli/commands/doc.rb#129
  def end_command(name); end

  # Called when all commands for the current context have been vended
  #
  # source://gli//lib/gli/commands/doc.rb#104
  def end_commands; end

  # Called when all options for the current context have been vended
  #
  # source://gli//lib/gli/commands/doc.rb#94
  def end_options; end

  # Called when processing has completed
  #
  # source://gli//lib/gli/commands/doc.rb#69
  def ending; end

  # Gives you a flag in the current context
  #
  # source://gli//lib/gli/commands/doc.rb#109
  def flag(name, aliases, desc, long_desc, default_value, arg_name, must_match, type); end

  # Called at the start of options for the current context
  #
  # source://gli//lib/gli/commands/doc.rb#89
  def options; end

  # Gives you the program description
  #
  # source://gli//lib/gli/commands/doc.rb#74
  def program_desc(desc); end

  # Gives you the program long description
  #
  # source://gli//lib/gli/commands/doc.rb#79
  def program_long_desc(desc); end

  # Gives you a switch in the current context
  #
  # source://gli//lib/gli/commands/doc.rb#114
  def switch(name, aliases, desc, long_desc, negatable); end

  # Gives you the program version
  #
  # source://gli//lib/gli/commands/doc.rb#84
  def version(version); end

  private

  # source://gli//lib/gli/commands/doc.rb#134
  def abstract!; end
end

# source://gli//lib/gli/commands/doc.rb#6
GLI::Commands::Doc::FORMATS = T.let(T.unsafe(nil), Hash)

# The help command used for the two-level interactive help system
#
# source://gli//lib/gli/commands/help.rb#41
class GLI::Commands::Help < ::GLI::Command
  # @return [Help] a new instance of Help
  #
  # source://gli//lib/gli/commands/help.rb#58
  def initialize(app, output = T.unsafe(nil), error = T.unsafe(nil)); end

  # source://gli//lib/gli/commands/help.rb#84
  def skips_around; end

  # source://gli//lib/gli/commands/help.rb#83
  def skips_post; end

  # source://gli//lib/gli/commands/help.rb#82
  def skips_pre; end

  private

  # source://gli//lib/gli/commands/help.rb#88
  def show_help(global_options, options, arguments, out, error); end

  class << self
    # Configure help to explicitly skip or not skip the around block when the help command runs.
    # This is here because the creation of the help command is outside of the client programmer's control
    #
    # source://gli//lib/gli/commands/help.rb#56
    def skips_around=(skips_around); end

    # Configure help to explicitly skip or not skip the post block when the help command runs.
    # This is here because the creation of the help command is outside of the client programmer's control
    #
    # source://gli//lib/gli/commands/help.rb#52
    def skips_post=(skips_post); end

    # Configure help to explicitly skip or not skip the pre block when the help command runs.
    # This is here because the creation of the help command is outside of the client programmer's control
    #
    # source://gli//lib/gli/commands/help.rb#48
    def skips_pre=(skips_pre); end
  end
end

# source://gli//lib/gli/commands/help_modules/list_formatter.rb#3
module GLI::Commands::HelpModules; end

# Handles wrapping text
#
# source://gli//lib/gli/commands/help_modules/arg_name_formatter.rb#5
class GLI::Commands::HelpModules::ArgNameFormatter
  # source://gli//lib/gli/commands/help_modules/arg_name_formatter.rb#6
  def format(arguments_description, arguments_options, arguments); end

  # source://gli//lib/gli/commands/help_modules/arg_name_formatter.rb#33
  def format_argname(arguments_description, arguments_options); end

  # source://gli//lib/gli/commands/help_modules/arg_name_formatter.rb#14
  def format_arguments(arguments); end
end

# Finds commands from the application/command data structures
#
# source://gli//lib/gli/commands/help_modules/command_finder.rb#5
class GLI::Commands::HelpModules::CommandFinder
  # @return [CommandFinder] a new instance of CommandFinder
  #
  # source://gli//lib/gli/commands/help_modules/command_finder.rb#11
  def initialize(app, arguments, error); end

  # source://gli//lib/gli/commands/help_modules/command_finder.rb#19
  def find_command(name); end

  # Returns the value of attribute last_found_command.
  #
  # source://gli//lib/gli/commands/help_modules/command_finder.rb#8
  def last_found_command; end

  # Returns the value of attribute last_unknown_command.
  #
  # source://gli//lib/gli/commands/help_modules/command_finder.rb#7
  def last_unknown_command; end

  # Sets the attribute squelch_stderr
  #
  # @param value the value to set the attribute squelch_stderr to.
  #
  # source://gli//lib/gli/commands/help_modules/command_finder.rb#9
  def squelch_stderr=(_arg0); end

  private

  # Given the name of a command to find, and a base, either the app or another command, returns
  # the command object or nil.
  #
  # source://gli//lib/gli/commands/help_modules/command_finder.rb#36
  def find_command_from_base(command_name, base); end

  # Checks if the return from find_command was unknown and, if so, prints an error
  # for the user on the error device, returning true or false if the command was unknown.
  #
  # @return [Boolean]
  #
  # source://gli//lib/gli/commands/help_modules/command_finder.rb#46
  def unknown_command?(command, name, error); end
end

# source://gli//lib/gli/commands/help_modules/command_help_format.rb#6
class GLI::Commands::HelpModules::CommandHelpFormat
  # @return [CommandHelpFormat] a new instance of CommandHelpFormat
  #
  # source://gli//lib/gli/commands/help_modules/command_help_format.rb#7
  def initialize(command, app, sorter, synopsis_formatter_class, wrapper_class = T.unsafe(nil)); end

  # source://gli//lib/gli/commands/help_modules/command_help_format.rb#15
  def format; end

  private

  # source://gli//lib/gli/commands/help_modules/command_help_format.rb#51
  def flags_and_switches(command, app); end

  # source://gli//lib/gli/commands/help_modules/command_help_format.rb#80
  def format_examples(command); end

  # source://gli//lib/gli/commands/help_modules/command_help_format.rb#65
  def format_subcommands(command); end
end

# source://gli//lib/gli/commands/help_modules/command_help_format.rb#28
GLI::Commands::HelpModules::CommandHelpFormat::COMMAND_HELP = T.let(T.unsafe(nil), ERB)

# source://gli//lib/gli/commands/help_modules/compact_synopsis_formatter.rb#4
class GLI::Commands::HelpModules::CompactSynopsisFormatter < ::GLI::Commands::HelpModules::FullSynopsisFormatter
  protected

  # source://gli//lib/gli/commands/help_modules/compact_synopsis_formatter.rb#8
  def sub_options_doc(sub_options); end
end

# source://gli//lib/gli/commands/help_modules/full_synopsis_formatter.rb#4
class GLI::Commands::HelpModules::FullSynopsisFormatter
  # @return [FullSynopsisFormatter] a new instance of FullSynopsisFormatter
  #
  # source://gli//lib/gli/commands/help_modules/full_synopsis_formatter.rb#5
  def initialize(app, flags_and_switches); end

  # source://gli//lib/gli/commands/help_modules/full_synopsis_formatter.rb#11
  def synopses_for_command(command); end

  protected

  # source://gli//lib/gli/commands/help_modules/full_synopsis_formatter.rb#28
  def sub_options_doc(sub_options); end

  private

  # source://gli//lib/gli/commands/help_modules/full_synopsis_formatter.rb#50
  def basic_usage(command); end

  # source://gli//lib/gli/commands/help_modules/full_synopsis_formatter.rb#60
  def command_with_subcommand_usage(command, sub, is_default_command); end

  # source://gli//lib/gli/commands/help_modules/full_synopsis_formatter.rb#103
  def global_flags_and_switches; end

  # source://gli//lib/gli/commands/help_modules/full_synopsis_formatter.rb#39
  def path_to_command(command); end

  # source://gli//lib/gli/commands/help_modules/full_synopsis_formatter.rb#85
  def sorted_synopses(command); end
end

# source://gli//lib/gli/commands/help_modules/global_help_format.rb#6
class GLI::Commands::HelpModules::GlobalHelpFormat
  # @return [GlobalHelpFormat] a new instance of GlobalHelpFormat
  #
  # source://gli//lib/gli/commands/help_modules/global_help_format.rb#7
  def initialize(app, sorter, wrapper_class); end

  # source://gli//lib/gli/commands/help_modules/global_help_format.rb#13
  def format; end

  private

  # source://gli//lib/gli/commands/help_modules/global_help_format.rb#54
  def global_flags_and_switches; end

  # source://gli//lib/gli/commands/help_modules/global_help_format.rb#58
  def usage_string; end
end

# source://gli//lib/gli/commands/help_modules/global_help_format.rb#37
GLI::Commands::HelpModules::GlobalHelpFormat::GLOBAL_HELP = T.let(T.unsafe(nil), ERB)

# source://gli//lib/gli/commands/help_modules/help_completion_format.rb#4
class GLI::Commands::HelpModules::HelpCompletionFormat
  # @return [HelpCompletionFormat] a new instance of HelpCompletionFormat
  #
  # source://gli//lib/gli/commands/help_modules/help_completion_format.rb#5
  def initialize(app, command_finder, args); end

  # source://gli//lib/gli/commands/help_modules/help_completion_format.rb#12
  def format; end
end

# Given a list of two-element lists, formats on the terminal
#
# source://gli//lib/gli/commands/help_modules/list_formatter.rb#5
class GLI::Commands::HelpModules::ListFormatter
  # @return [ListFormatter] a new instance of ListFormatter
  #
  # source://gli//lib/gli/commands/help_modules/list_formatter.rb#6
  def initialize(list, wrapper_class = T.unsafe(nil)); end

  # Output the list to the output_device
  #
  # source://gli//lib/gli/commands/help_modules/list_formatter.rb#12
  def output(output_device); end
end

# Formats text in one line, stripping newlines and NOT wrapping
#
# source://gli//lib/gli/commands/help_modules/one_line_wrapper.rb#5
class GLI::Commands::HelpModules::OneLineWrapper
  # Args are ignored entirely; this keeps it consistent with the TextWrapper interface
  #
  # @return [OneLineWrapper] a new instance of OneLineWrapper
  #
  # source://gli//lib/gli/commands/help_modules/one_line_wrapper.rb#7
  def initialize(width, indent); end

  # Return a wrapped version of text, assuming that the first line has already been
  # indented by @indent characters.  Resulting text does NOT have a newline in it.
  #
  # source://gli//lib/gli/commands/help_modules/one_line_wrapper.rb#12
  def wrap(text); end
end

# source://gli//lib/gli/commands/help_modules/options_formatter.rb#4
class GLI::Commands::HelpModules::OptionsFormatter
  # @return [OptionsFormatter] a new instance of OptionsFormatter
  #
  # source://gli//lib/gli/commands/help_modules/options_formatter.rb#5
  def initialize(flags_and_switches, sorter, wrapper_class); end

  # source://gli//lib/gli/commands/help_modules/options_formatter.rb#10
  def format; end

  private

  # source://gli//lib/gli/commands/help_modules/options_formatter.rb#25
  def description_with_default(option); end

  # source://gli//lib/gli/commands/help_modules/options_formatter.rb#36
  def option_names_for_help_string(option, arg_name = T.unsafe(nil)); end
end

# Formats text in one line, stripping newlines and NOT wrapping
#
# source://gli//lib/gli/commands/help_modules/tty_only_wrapper.rb#5
class GLI::Commands::HelpModules::TTYOnlyWrapper
  # Args are ignored entirely; this keeps it consistent with the TextWrapper interface
  #
  # @return [TTYOnlyWrapper] a new instance of TTYOnlyWrapper
  #
  # source://gli//lib/gli/commands/help_modules/tty_only_wrapper.rb#7
  def initialize(width, indent); end

  # Return a wrapped version of text, assuming that the first line has already been
  # indented by @indent characters.  Resulting text does NOT have a newline in it.
  #
  # source://gli//lib/gli/commands/help_modules/tty_only_wrapper.rb#17
  def wrap(text); end
end

# source://gli//lib/gli/commands/help_modules/terminal_synopsis_formatter.rb#4
class GLI::Commands::HelpModules::TerminalSynopsisFormatter
  # @return [TerminalSynopsisFormatter] a new instance of TerminalSynopsisFormatter
  #
  # source://gli//lib/gli/commands/help_modules/terminal_synopsis_formatter.rb#5
  def initialize(app, flags_and_switches); end

  # source://gli//lib/gli/commands/help_modules/terminal_synopsis_formatter.rb#10
  def synopses_for_command(command); end
end

# Handles wrapping text
#
# source://gli//lib/gli/commands/help_modules/text_wrapper.rb#5
class GLI::Commands::HelpModules::TextWrapper
  # Create a text_wrapper wrapping at the given width,
  # and indent.
  #
  # @return [TextWrapper] a new instance of TextWrapper
  #
  # source://gli//lib/gli/commands/help_modules/text_wrapper.rb#8
  def initialize(width, indent); end

  # Return a wrapped version of text, assuming that the first line has already been
  # indented by @indent characters.  Resulting text does NOT have a newline in it.
  #
  # source://gli//lib/gli/commands/help_modules/text_wrapper.rb#15
  def wrap(text); end
end

# Leaves text formatting exactly as it was received. Doesn't strip anything.
#
# source://gli//lib/gli/commands/help_modules/verbatim_wrapper.rb#5
class GLI::Commands::HelpModules::VerbatimWrapper
  # Args are ignored entirely; this keeps it consistent with the TextWrapper interface
  #
  # @return [VerbatimWrapper] a new instance of VerbatimWrapper
  #
  # source://gli//lib/gli/commands/help_modules/verbatim_wrapper.rb#7
  def initialize(width, indent); end

  # source://gli//lib/gli/commands/help_modules/verbatim_wrapper.rb#10
  def wrap(text); end
end

# source://gli//lib/gli/commands/rdoc_document_listener.rb#5
class GLI::Commands::RdocDocumentListener
  # @return [RdocDocumentListener] a new instance of RdocDocumentListener
  #
  # source://gli//lib/gli/commands/rdoc_document_listener.rb#7
  def initialize(global_options, options, arguments, app); end

  # source://gli//lib/gli/commands/rdoc_document_listener.rb#14
  def beginning; end

  # Gives you a command in the current context and creates a new context of this command
  #
  # source://gli//lib/gli/commands/rdoc_document_listener.rb#84
  def command(name, aliases, desc, long_desc, arg_name, arg_options); end

  # source://gli//lib/gli/commands/rdoc_document_listener.rb#78
  def commands; end

  # Gives you the name of the current command in the current context
  #
  # source://gli//lib/gli/commands/rdoc_document_listener.rb#98
  def default_command(name); end

  # Ends a command, and "pops" you back up one context
  #
  # source://gli//lib/gli/commands/rdoc_document_listener.rb#93
  def end_command(name); end

  # source://gli//lib/gli/commands/rdoc_document_listener.rb#102
  def end_commands; end

  # source://gli//lib/gli/commands/rdoc_document_listener.rb#75
  def end_options; end

  # Called when processing has completed
  #
  # source://gli//lib/gli/commands/rdoc_document_listener.rb#18
  def ending; end

  # Gives you a flag in the current context
  #
  # source://gli//lib/gli/commands/rdoc_document_listener.rb#48
  def flag(name, aliases, desc, long_desc, default_value, arg_name, must_match, type); end

  # source://gli//lib/gli/commands/rdoc_document_listener.rb#39
  def options; end

  # Gives you the program description
  #
  # source://gli//lib/gli/commands/rdoc_document_listener.rb#23
  def program_desc(desc); end

  # source://gli//lib/gli/commands/rdoc_document_listener.rb#28
  def program_long_desc(desc); end

  # Gives you a switch in the current context
  #
  # source://gli//lib/gli/commands/rdoc_document_listener.rb#62
  def switch(name, aliases, desc, long_desc, negatable); end

  # Gives you the program version
  #
  # source://gli//lib/gli/commands/rdoc_document_listener.rb#34
  def version(version); end

  private

  # source://gli//lib/gli/commands/rdoc_document_listener.rb#108
  def add_dashes(name); end
end

# source://gli//lib/gli/commands/help.rb#21
GLI::Commands::SORTERS = T.let(T.unsafe(nil), Hash)

# source://gli//lib/gli/commands/help.rb#35
GLI::Commands::SYNOPSIS_FORMATTERS = T.let(T.unsafe(nil), Hash)

# source://gli//lib/gli/commands/help.rb#26
GLI::Commands::WRAPPERS = T.let(T.unsafe(nil), Hash)

# Raise this if you want to use an exit status that isn't the default
# provided by GLI.  Note that GLI::App#exit_now! might be a bit more to your liking.
#
# Example:
#
#     raise CustomExit.new("Not connected to DB",-5) unless connected?
#     raise CustomExit.new("Bad SQL",-6) unless valid_sql?(args[0])
#
# source://gli//lib/gli/exceptions.rb#110
class GLI::CustomExit < ::StandardError
  include ::GLI::StandardException

  # Create a custom exit exception
  #
  # +message+:: String containing error message to show the user
  # +exit_code+:: the exit code to use (as an Int), overridding GLI's default
  #
  # @return [CustomExit] a new instance of CustomExit
  #
  # source://gli//lib/gli/exceptions.rb#117
  def initialize(message, exit_code); end

  # source://gli//lib/gli/exceptions.rb#112
  def exit_code; end
end

# The primary DSL for GLI.  This represents the methods shared between your top-level app and
# the commands.  See GLI::Command for additional methods that apply only to command objects.
#
# source://gli//lib/gli/dsl.rb#4
module GLI::DSL
  # Describes one of the arguments of the next command
  #
  # +name+:: A String that *briefly* describes the argument given to the following command.
  # +options+:: Symbol or array of symbols to annotate this argument.  This doesn't affect parsing, just
  #             the help output.  Values recognized are:
  #             +:optional+:: indicates this argument is optional; will format it with square brackets
  #             +:multiple+:: indicates multiple values are accepted; will format appropriately
  #
  # Example:
  #     arg :output
  #     arg :input, :multiple
  #     command :pack do ...
  #
  # Produces the synopsis:
  #     app.rb [global options] pack output input...
  #
  # source://gli//lib/gli/dsl.rb#54
  def arg(name, options = T.unsafe(nil)); end

  # Describe the argument name of the next flag.  It's important to keep
  # this VERY short and, ideally, without any spaces (see Example).
  #
  # +name+:: A String that *briefly* describes the argument given to the following command or flag.
  # +options+:: Symbol or array of symbols to annotate this argument.  This doesn't affect parsing, just
  #             the help output.  Values recognized are:
  #             +:optional+:: indicates this argument is optional; will format it with square brackets
  #             +:multiple+:: indicates multiple values are accepted; will format appropriately
  #
  # Example:
  #     desc 'Set the filename'
  #     arg_name 'file_name'
  #     flag [:f,:filename]
  #
  # Produces:
  #     -f, --filename=file_name      Set the filename
  #
  # source://gli//lib/gli/dsl.rb#34
  def arg_name(name, options = T.unsafe(nil)); end

  # Define a new command.  This can be done in a few ways, but the most common method is
  # to pass a symbol (or Array of symbols) representing the command name (or names) and a block.
  # The block will be given an instance of the Command that was created.
  # You then may call methods on this object to define aspects of that Command.
  #
  # Alternatively, you can call this with a one element Hash, where the key is the symbol representing the name
  # of the command, and the value being an Array of symbols representing the commands to call in order, as a
  # chained or compound command.  Note that these commands must exist already, and that only those command-specific
  # options defined in *this* command will be parsed and passed to the chained commands.  This might not be what you expect
  #
  # +names+:: a String or Symbol, or an Array of String or Symbol that represent all the different names and aliases
  #           for this command *or* a Hash, as described above.
  #
  # ==Examples
  #
  #     # Make a command named list
  #     command :list do |c|
  #       c.action do |global_options,options,args|
  #         # your command code
  #       end
  #     end
  #
  #     # Make a command named list, callable by ls as well
  #     command [:list,:ls] do |c|
  #       c.action do |global_options,options,args|
  #         # your command code
  #       end
  #     end
  #
  #     # Make a command named all, that calls list and list_contexts
  #     command :all => [ :list, :list_contexts ]
  #
  #     # Make a command named all, aliased as :a:, that calls list and list_contexts
  #     command [:all,:a] => [ :list, :list_contexts ]
  #
  # source://gli//lib/gli/dsl.rb#171
  def c(*names); end

  # source://gli//lib/gli/dsl.rb#128
  def clear_nexts; end

  # Define a new command.  This can be done in a few ways, but the most common method is
  # to pass a symbol (or Array of symbols) representing the command name (or names) and a block.
  # The block will be given an instance of the Command that was created.
  # You then may call methods on this object to define aspects of that Command.
  #
  # Alternatively, you can call this with a one element Hash, where the key is the symbol representing the name
  # of the command, and the value being an Array of symbols representing the commands to call in order, as a
  # chained or compound command.  Note that these commands must exist already, and that only those command-specific
  # options defined in *this* command will be parsed and passed to the chained commands.  This might not be what you expect
  #
  # +names+:: a String or Symbol, or an Array of String or Symbol that represent all the different names and aliases
  #           for this command *or* a Hash, as described above.
  #
  # ==Examples
  #
  #     # Make a command named list
  #     command :list do |c|
  #       c.action do |global_options,options,args|
  #         # your command code
  #       end
  #     end
  #
  #     # Make a command named list, callable by ls as well
  #     command [:list,:ls] do |c|
  #       c.action do |global_options,options,args|
  #         # your command code
  #       end
  #     end
  #
  #     # Make a command named all, that calls list and list_contexts
  #     command :all => [ :list, :list_contexts ]
  #
  #     # Make a command named all, aliased as :a:, that calls list and list_contexts
  #     command [:all,:a] => [ :list, :list_contexts ]
  #
  # source://gli//lib/gli/dsl.rb#171
  def command(*names); end

  # source://gli//lib/gli/dsl.rb#208
  def command_missing(&block); end

  # Describe the next switch, flag, or command.  This should be a
  # short, one-line description
  #
  # +description+:: A String of the short descripiton of the switch, flag, or command following
  #
  # source://gli//lib/gli/dsl.rb#9
  def d(description); end

  # set the default value of the next flag or switch
  #
  # +val+:: The default value to be used for the following flag if the user doesn't specify one
  #         and, when using a config file, the config also doesn't specify one.  For a switch, this is
  #         the value to be used if the switch isn't specified on the command-line.  Note that if you
  #         set a switch to have a default of true, using the switch on the command-line has no effect.
  #         To disable a switch where the default is true, use the <tt>--no-</tt> form.
  #
  # source://gli//lib/gli/dsl.rb#66
  def default_value(val); end

  # Describe the next switch, flag, or command.  This should be a
  # short, one-line description
  #
  # +description+:: A String of the short descripiton of the switch, flag, or command following
  #
  # source://gli//lib/gli/dsl.rb#9
  def desc(description); end

  # Create a flag, which is a switch that takes an argument
  #
  # +names+:: a String or Symbol, or an Array of String or Symbol that represent all the different names
  #           and aliases for this flag.  The last element can be a hash of options:
  #           +:desc+:: the description, instead of using #desc
  #           +:long_desc+:: the long_description, instead of using #long_desc
  #           +:default_value+:: the default value, instead of using #default_value
  #           +:arg_name+:: the arg name, instead of using #arg_name
  #           +:must_match+:: A regexp that the flag's value must match or an array of allowable values
  #           +:type+:: A Class (or object you passed to GLI::App#accept) to trigger type coversion
  #           +:multiple+:: if true, flag may be used multiple times and values are stored in an array
  #
  # Example:
  #
  #     desc 'Set the filename'
  #     flag [:f,:filename,'file-name']
  #
  #     flag :ipaddress, :desc => "IP Address", :must_match => /\d+\.\d+\.\d+\.\d+/
  #
  #     flag :names, :desc => "list of names", :type => Array
  #
  # Produces:
  #
  #     -f, --filename, --file-name=arg     Set the filename
  #
  # source://gli//lib/gli/dsl.rb#92
  def f(*names); end

  # Create a flag, which is a switch that takes an argument
  #
  # +names+:: a String or Symbol, or an Array of String or Symbol that represent all the different names
  #           and aliases for this flag.  The last element can be a hash of options:
  #           +:desc+:: the description, instead of using #desc
  #           +:long_desc+:: the long_description, instead of using #long_desc
  #           +:default_value+:: the default value, instead of using #default_value
  #           +:arg_name+:: the arg name, instead of using #arg_name
  #           +:must_match+:: A regexp that the flag's value must match or an array of allowable values
  #           +:type+:: A Class (or object you passed to GLI::App#accept) to trigger type coversion
  #           +:multiple+:: if true, flag may be used multiple times and values are stored in an array
  #
  # Example:
  #
  #     desc 'Set the filename'
  #     flag [:f,:filename,'file-name']
  #
  #     flag :ipaddress, :desc => "IP Address", :must_match => /\d+\.\d+\.\d+\.\d+/
  #
  #     flag :names, :desc => "list of names", :type => Array
  #
  # Produces:
  #
  #     -f, --filename, --file-name=arg     Set the filename
  #
  # source://gli//lib/gli/dsl.rb#92
  def flag(*names); end

  # source://gli//lib/gli/dsl.rb#212
  def flags_declaration_order; end

  # Provide a longer, more detailed description.  This
  # will be reformatted and wrapped to fit in the terminal's columns
  #
  # +long_desc+:: A String that is s longer description of the switch, flag, or command following.
  #
  # source://gli//lib/gli/dsl.rb#16
  def long_desc(long_desc); end

  # Create a switch, which is a command line flag that takes no arguments (thus, it _switches_ something on)
  #
  # +names+:: a String or Symbol, or an Array of String or Symbol that represent all the different names
  #           and aliases for this switch.  The last element can be a hash of options:
  #           +:desc+:: the description, instead of using #desc
  #           +:long_desc+:: the long_description, instead of using #long_desc
  #           +:default_value+:: if the switch is omitted, use this as the default value.  By default,  switches default to off, or +false+
  #           +:negatable+:: if true, this switch will get a negatable form (e.g. <tt>--[no-]switch</tt>, false it will not.  Default is true
  #
  # source://gli//lib/gli/dsl.rb#114
  def s(*names); end

  # Create a switch, which is a command line flag that takes no arguments (thus, it _switches_ something on)
  #
  # +names+:: a String or Symbol, or an Array of String or Symbol that represent all the different names
  #           and aliases for this switch.  The last element can be a hash of options:
  #           +:desc+:: the description, instead of using #desc
  #           +:long_desc+:: the long_description, instead of using #long_desc
  #           +:default_value+:: if the switch is omitted, use this as the default value.  By default,  switches default to off, or +false+
  #           +:negatable+:: if true, this switch will get a negatable form (e.g. <tt>--[no-]switch</tt>, false it will not.  Default is true
  #
  # source://gli//lib/gli/dsl.rb#114
  def switch(*names); end

  # source://gli//lib/gli/dsl.rb#216
  def switches_declaration_order; end

  private

  # Extract the options hash out of the argument to flag/switch and
  # set the values if using classic style
  #
  # source://gli//lib/gli/dsl.rb#244
  def extract_options(names); end

  # Checks that the names passed in have not been used in another flag or option
  #
  # source://gli//lib/gli/dsl.rb#223
  def verify_unused(names); end

  # @raise [ArgumentError]
  #
  # source://gli//lib/gli/dsl.rb#230
  def verify_unused_in_option(name, option_like, type); end
end

# Defines a flag, which is to say a switch that takes an argument
#
# source://gli//lib/gli/flag.rb#5
class GLI::Flag < ::GLI::CommandLineOption
  # Creates a new option
  #
  # names:: Array of symbols or strings representing the names of this switch
  # options:: hash of options:
  #           :desc:: the short description
  #           :long_desc:: the long description
  #           :default_value:: the default value of this option
  #           :arg_name:: the name of the flag's argument, default is "arg"
  #           :must_match:: a regexp that the flag's value must match
  #           :type:: a class to convert the value to
  #           :required:: if true, this flag must be specified on the command line
  #           :multiple:: if true, flag may be used multiple times and values are stored in an array
  #           :mask:: if true, the default value of this flag will not be output in the help.
  #                   This is useful for password flags where you might not want to show it
  #                   on the command-line.
  #
  # @return [Flag] a new instance of Flag
  #
  # source://gli//lib/gli/flag.rb#31
  def initialize(names, options); end

  # Returns a string of all possible forms
  # of this flag.  Mostly intended for printing
  # to the user.
  #
  # source://gli//lib/gli/flag.rb#85
  def all_forms(joiner = T.unsafe(nil)); end

  # Name of the argument that user configured
  #
  # source://gli//lib/gli/flag.rb#14
  def argument_name; end

  # source://gli//lib/gli/flag.rb#75
  def arguments_for_option_parser; end

  # The default value for this flag. Uses the value passed if one is set;
  # otherwise uses `[]` if the flag support multiple arguments and `nil` if
  # it does not.
  #
  # source://gli//lib/gli/flag.rb#67
  def default_value; end

  # True if the flag may be used multiple times.
  #
  # @return [Boolean]
  #
  # source://gli//lib/gli/flag.rb#47
  def multiple?; end

  # Regexp that is used to see if the flag's argument matches
  #
  # source://gli//lib/gli/flag.rb#8
  def must_match; end

  # True if this flag is required on the command line
  #
  # @return [Boolean]
  #
  # source://gli//lib/gli/flag.rb#42
  def required?; end

  # source://gli//lib/gli/flag.rb#51
  def safe_default_value; end

  # Type to which we want to cast the values
  #
  # source://gli//lib/gli/flag.rb#11
  def type; end
end

# An "option block" is a set of parseable options, starting from the beginning of
# the argument list, stopping with the first unknown command-line element.
# This class handles parsing that block
#
# source://gli//lib/gli/gli_option_block_parser.rb#5
class GLI::GLIOptionBlockParser
  # Create the parser using the given +OptionParser+ instance and exception handling
  # strategy.
  #
  # option_parser_factory:: An +OptionParserFactory+ instance, configured to parse wherever you are on the command line
  # exception_klass_or_block:: means of handling exceptions from +OptionParser+.  One of:
  #                            an exception class:: will be raised on errors with a message
  #                            lambda/block:: will be called with a single argument - the error message.
  #
  # @return [GLIOptionBlockParser] a new instance of GLIOptionBlockParser
  #
  # source://gli//lib/gli/gli_option_block_parser.rb#14
  def initialize(option_parser_factory, exception_klass_or_block); end

  # Parse the given argument list, returning the unparsed arguments and options hash of parsed arguments.
  # Exceptions from +OptionParser+ are given to the handler configured in the constructor
  #
  # args:: argument list.  This will be mutated
  #
  # Returns unparsed args
  #
  # source://gli//lib/gli/gli_option_block_parser.rb#32
  def parse!(args); end

  protected

  # source://gli//lib/gli/gli_option_block_parser.rb#42
  def do_parse(args); end
end

# Parses the command-line options using an actual +OptionParser+
#
# source://gli//lib/gli/gli_option_parser.rb#3
class GLI::GLIOptionParser
  # @return [GLIOptionParser] a new instance of GLIOptionParser
  #
  # source://gli//lib/gli/gli_option_parser.rb#13
  def initialize(commands, flags, switches, accepts, options = T.unsafe(nil)); end

  # Returns the value of attribute options.
  #
  # source://gli//lib/gli/gli_option_parser.rb#4
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://gli//lib/gli/gli_option_parser.rb#4
  def options=(_arg0); end

  # Given the command-line argument array, returns an OptionParsingResult
  #
  # source://gli//lib/gli/gli_option_parser.rb#27
  def parse_options(args); end
end

# source://gli//lib/gli/gli_option_parser.rb#6
GLI::GLIOptionParser::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://gli//lib/gli/gli_option_parser.rb#38
class GLI::GLIOptionParser::GlobalOptionParser
  # @return [GlobalOptionParser] a new instance of GlobalOptionParser
  #
  # source://gli//lib/gli/gli_option_parser.rb#39
  def initialize(option_parser_factory, command_finder, flags, options = T.unsafe(nil)); end

  # source://gli//lib/gli/gli_option_parser.rb#46
  def parse!(parsing_result); end

  protected

  # source://gli//lib/gli/gli_option_parser.rb#76
  def verify_arguments!(arguments, command); end

  # source://gli//lib/gli/gli_option_parser.rb#107
  def verify_required_options!(flags, command, options); end
end

# source://gli//lib/gli/gli_option_parser.rb#191
class GLI::GLIOptionParser::LegacyCommandOptionParser < ::GLI::GLIOptionParser::NormalCommandOptionParser
  # source://gli//lib/gli/gli_option_parser.rb#192
  def parse!(parsing_result, argument_handling_strategy, autocomplete); end

  private

  # source://gli//lib/gli/gli_option_parser.rb#209
  def find_subcommand(command, arguments, autocomplete); end
end

# source://gli//lib/gli/gli_option_parser.rb#120
class GLI::GLIOptionParser::NormalCommandOptionParser < ::GLI::GLIOptionParser::GlobalOptionParser
  # @return [NormalCommandOptionParser] a new instance of NormalCommandOptionParser
  #
  # source://gli//lib/gli/gli_option_parser.rb#121
  def initialize(accepts); end

  # source://gli//lib/gli/gli_option_parser.rb#125
  def error_handler; end

  # source://gli//lib/gli/gli_option_parser.rb#131
  def parse!(parsing_result, argument_handling_strategy, autocomplete); end
end

# Command that initializes the configuration file for apps that use it.
#
# source://gli//lib/gli/commands/initconfig.rb#8
class GLI::InitConfig < ::GLI::Command
  # @return [InitConfig] a new instance of InitConfig
  #
  # source://gli//lib/gli/commands/initconfig.rb#11
  def initialize(config_file_name, commands, flags, switches); end

  private

  # source://gli//lib/gli/commands/initconfig.rb#59
  def config_for_command(commands, command_name); end

  # source://gli//lib/gli/commands/initconfig.rb#37
  def create_config(global_options, options, arguments); end
end

# source://gli//lib/gli/commands/initconfig.rb#9
GLI::InitConfig::COMMANDS_KEY = T.let(T.unsafe(nil), String)

# source://gli//lib/gli/gli_option_block_parser.rb#77
class GLI::LegacyCommandOptionBlockParser < ::GLI::CommandOptionBlockParser
  protected

  # @return [Boolean]
  #
  # source://gli//lib/gli/gli_option_block_parser.rb#80
  def break_on_non_option?; end
end

# source://gli//lib/gli/exceptions.rb#71
class GLI::MissingRequiredArgumentsException < ::GLI::BadCommandOptionsOrArguments
  # @return [MissingRequiredArgumentsException] a new instance of MissingRequiredArgumentsException
  #
  # source://gli//lib/gli/exceptions.rb#73
  def initialize(command, num_arguments_received, range_arguments_accepted); end

  # Returns the value of attribute num_arguments_received.
  #
  # source://gli//lib/gli/exceptions.rb#72
  def num_arguments_received; end

  # Returns the value of attribute range_arguments_accepted.
  #
  # source://gli//lib/gli/exceptions.rb#72
  def range_arguments_accepted; end
end

# source://gli//lib/gli/exceptions.rb#90
class GLI::MissingRequiredOptionsException < ::GLI::BadCommandOptionsOrArguments
  # @return [MissingRequiredOptionsException] a new instance of MissingRequiredOptionsException
  #
  # source://gli//lib/gli/exceptions.rb#91
  def initialize(command, missing_required_options); end
end

# Factory for creating an OptionParser based on app configuration and DSL calls
#
# source://gli//lib/gli/option_parser_factory.rb#3
class GLI::OptionParserFactory
  # Create an OptionParserFactory for the given
  # flags, switches, and accepts
  #
  # @return [OptionParserFactory] a new instance of OptionParserFactory
  #
  # source://gli//lib/gli/option_parser_factory.rb#17
  def initialize(flags, switches, accepts); end

  # Returns the value of attribute option_parser.
  #
  # source://gli//lib/gli/option_parser_factory.rb#28
  def option_parser; end

  # Returns the value of attribute options_hash.
  #
  # source://gli//lib/gli/option_parser_factory.rb#29
  def options_hash; end

  # source://gli//lib/gli/option_parser_factory.rb#31
  def options_hash_with_defaults_set!; end

  private

  # source://gli//lib/gli/option_parser_factory.rb#39
  def set_defaults(options_by_name, options_hash); end

  class << self
    # source://gli//lib/gli/option_parser_factory.rb#75
    def add_help_switches_to_command(option_parser, command); end

    # Create an option parser factory for a command.  This has the added
    # feature of setting up -h and --help on the command if those
    # options aren't otherwise configured, e.g. to allow todo add --help as an
    # alternate to todo help add
    #
    # source://gli//lib/gli/option_parser_factory.rb#9
    def for_command(command, accepts); end

    # source://gli//lib/gli/option_parser_factory.rb#49
    def setup_accepts(opts, accepts); end

    # source://gli//lib/gli/option_parser_factory.rb#57
    def setup_options(opts, tokens, options); end
  end
end

# source://gli//lib/gli/option_parsing_result.rb#2
class GLI::OptionParsingResult
  # Returns the value of attribute arguments.
  #
  # source://gli//lib/gli/option_parsing_result.rb#6
  def arguments; end

  # Sets the attribute arguments
  #
  # @param value the value to set the attribute arguments to.
  #
  # source://gli//lib/gli/option_parsing_result.rb#6
  def arguments=(_arg0); end

  # Returns the value of attribute command.
  #
  # source://gli//lib/gli/option_parsing_result.rb#4
  def command; end

  # Sets the attribute command
  #
  # @param value the value to set the attribute command to.
  #
  # source://gli//lib/gli/option_parsing_result.rb#4
  def command=(_arg0); end

  # Returns the value of attribute command_options.
  #
  # source://gli//lib/gli/option_parsing_result.rb#5
  def command_options; end

  # Sets the attribute command_options
  #
  # @param value the value to set the attribute command_options to.
  #
  # source://gli//lib/gli/option_parsing_result.rb#5
  def command_options=(_arg0); end

  # source://gli//lib/gli/option_parsing_result.rb#8
  def convert_to_openstruct!; end

  # Returns the value of attribute global_options.
  #
  # source://gli//lib/gli/option_parsing_result.rb#3
  def global_options; end

  # Sets the attribute global_options
  #
  # @param value the value to set the attribute global_options to.
  #
  # source://gli//lib/gli/option_parsing_result.rb#3
  def global_options=(_arg0); end

  # Allows us to splat this object into blocks and methods expecting parameters in this order
  #
  # source://gli//lib/gli/option_parsing_result.rb#15
  def to_a; end
end

# Subclass of +OpenStruct+ that provides hash-like methods for #[] and #[]=.  Note that is is *not* a Hash.
# By using GLI::App#use_openstruct, your options will be coerced into one of these.
#
# source://gli//lib/gli/options.rb#6
class GLI::Options < ::OpenStruct
  # Return the value of an attribute
  #
  # source://gli//lib/gli/options.rb#9
  def [](k); end

  # Set the value of an attribute
  #
  # source://gli//lib/gli/options.rb#14
  def []=(k, v); end

  # source://gli//lib/gli/options.rb#18
  def map(&block); end
end

# source://gli//lib/gli/exceptions.rb#29
class GLI::PreconditionFailed < ::StandardError
  include ::GLI::StandardException

  # source://gli//lib/gli/exceptions.rb#31
  def exit_code; end
end

# Hack to request help from within a command
# Will *not* be rethrown when GLI_DEBUG is ON
#
# source://gli//lib/gli/exceptions.rb#11
class GLI::RequestHelp < ::StandardError
  include ::GLI::StandardException

  # @return [RequestHelp] a new instance of RequestHelp
  #
  # source://gli//lib/gli/exceptions.rb#18
  def initialize(command_in_context); end

  # The command for which the argument was unknown
  #
  # source://gli//lib/gli/exceptions.rb#16
  def command_in_context; end

  # source://gli//lib/gli/exceptions.rb#13
  def exit_code; end
end

# Mixed into all exceptions that GLI handles; you can use this to catch
# anything that came from GLI intentionally.  You can also mix this into non-GLI
# exceptions to get GLI's exit behavior.
#
# source://gli//lib/gli/exceptions.rb#5
module GLI::StandardException
  # source://gli//lib/gli/exceptions.rb#6
  def exit_code; end
end

# Defines a command line switch
#
# source://gli//lib/gli/switch.rb#5
class GLI::Switch < ::GLI::CommandLineOption
  # Creates a new switch
  #
  # names - Array of symbols or strings representing the names of this switch
  # options - hash of options:
  #           :desc - the short description
  #           :long_desc - the long description
  #           :negatable - true or false if this switch is negatable; defaults to true
  #           :default_value - default value if the switch is omitted
  #
  # @return [Switch] a new instance of Switch
  #
  # source://gli//lib/gli/switch.rb#18
  def initialize(names, options = T.unsafe(nil)); end

  # source://gli//lib/gli/switch.rb#27
  def arguments_for_option_parser; end

  # source://gli//lib/gli/switch.rb#7
  def default_value; end

  # source://gli//lib/gli/switch.rb#7
  def default_value=(_arg0); end

  # Returns the value of attribute negatable.
  #
  # source://gli//lib/gli/switch.rb#8
  def negatable; end

  # @return [Boolean]
  #
  # source://gli//lib/gli/switch.rb#31
  def negatable?; end

  # @return [Boolean]
  #
  # source://gli//lib/gli/switch.rb#35
  def required?; end
end

# Class to encapsulate stuff about the terminal. This is useful to application developers
# as a canonical means to get information about the user's current terminal configuraiton.
# GLI uses this to determine the number of columns to use when printing to the screen.
#
# To access it, use Terminal.instance.  This is a singleton mostly to facilitate testing, but
# it seems reasonable enough, since there's only one terminal in effect
#
# Example:
#
#     Terminal.instance.size[0] # => columns in the terminal
#     Terminal.default_size = [128,24] # => change default when we can't figure it out
#     raise "no ls?!?!?" unless Terminal.instance.command_exists?("ls")
#
# source://gli//lib/gli/terminal.rb#15
class GLI::Terminal
  # @return [Boolean]
  #
  # source://gli//lib/gli/terminal.rb#49
  def command_exists?(command); end

  # Call this to cause methods to throw exceptions rather than return a sane default.  You
  # probably don't want to call this unless you are writing tests
  #
  # source://gli//lib/gli/terminal.rb#38
  def make_unsafe!; end

  # Get the size of the current terminal.
  # Ripped from hirb[https://github.com/cldwalker/hirb/blob/master/lib/hirb/util.rb]
  #
  # Returns an Array of size two Ints representing the terminal width and height
  #
  # source://gli//lib/gli/terminal.rb#80
  def size; end

  class << self
    # Returns true if the given command exists on this system
    #
    # +command+:: The command, as a String, to check for, without any path information.
    #
    # @return [Boolean]
    #
    # source://gli//lib/gli/terminal.rb#45
    def command_exists?(command); end

    # Get the default size of the terminal when we can't figure it out
    #
    # Returns an array of int [cols,rows]
    #
    # source://gli//lib/gli/terminal.rb#22
    def default_size; end

    # Set the default size of the terminal to use when we can't figure it out
    #
    # +size+:: array of two int [cols,rows]
    #
    # source://gli//lib/gli/terminal.rb#29
    def default_size=(size); end

    # Provide access to the shared instance.
    #
    # source://gli//lib/gli/terminal.rb#34
    def instance; end

    # True if we are JRuby; exposed to allow for testing
    #
    # @return [Boolean]
    #
    # source://gli//lib/gli/terminal.rb#99
    def jruby?; end

    # Runs a command using backticks.  Extracted to allow for testing
    #
    # source://gli//lib/gli/terminal.rb#94
    def run_command(command); end

    # True if this is running under Solaris Sparc
    #
    # @return [Boolean]
    #
    # source://gli//lib/gli/terminal.rb#102
    def solaris?; end
  end
end

# source://gli//lib/gli/terminal.rb#53
GLI::Terminal::SIZE_DETERMINERS = T.let(T.unsafe(nil), Array)

# Indicates the bad command line was an unknown command
#
# source://gli//lib/gli/exceptions.rb#35
class GLI::UnknownCommand < ::GLI::BadCommandLine; end

# Indicates the bad command line was an unknown command argument
#
# source://gli//lib/gli/exceptions.rb#99
class GLI::UnknownCommandArgument < ::GLI::CommandException; end

# Indicates the bad command line was an unknown global argument
#
# source://gli//lib/gli/exceptions.rb#43
class GLI::UnknownGlobalArgument < ::GLI::BadCommandLine; end

# source://gli//lib/gli/version.rb#3
GLI::VERSION = T.let(T.unsafe(nil), String)
